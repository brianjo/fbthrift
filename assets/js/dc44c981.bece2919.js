"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[520],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>m,MDXProvider:()=>c,mdx:()=>f,useMDXComponents:()=>l,withMDXComponents:()=>p});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(){return s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},s.apply(this,arguments)}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var m=r.createContext({}),p=function(e){return function(t){var n=l(t.components);return r.createElement(e,s({},t,{components:n}))}},l=function(e){var t=r.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(m.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,o=e.parentName,m=d(e,["components","mdxType","originalType","parentName"]),p=l(n),c=a,u=p["".concat(o,".").concat(c)]||p[c]||h[c]||s;return n?r.createElement(u,i(i({ref:t},m),{},{components:n})):r.createElement(u,i({ref:t},m))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,o=new Array(s);o[0]=u;var i={};for(var d in t)hasOwnProperty.call(t,d)&&(i[d]=t[d]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var m=2;m<s;m++)o[m]=n[m];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},43126:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>l,frontMatter:()=>s,metadata:()=>i,toc:()=>m});var r=n(83117),a=(n(67294),n(3905));const s={state:"draft"},o="Interface Protocols",i={unversionedId:"spec/protocol/interface/index",id:"spec/protocol/interface/index",title:"Interface Protocols",description:"This document describes the layer immediately preceding the transport protocol (eg. Rocket). This layer specifies how the request/response data must be serialized and formatted before being wrapped in the underlying transport protocol layer's message format.",source:"@site/../doc/spec/protocol/interface/index.md",sourceDirName:"spec/protocol/interface",slug:"/spec/protocol/interface/",permalink:"/fbthrift/docs/spec/protocol/interface/",draft:!1,editUrl:"https://github.com/facebook/fbthrift/blob/main/thrift/website/../doc/spec/protocol/interface/index.md",tags:[],version:"current",frontMatter:{state:"draft"},sidebar:"sidebar",previous:{title:"Data Protocols",permalink:"/fbthrift/docs/spec/protocol/data"},next:{title:"Rocket Protocol",permalink:"/fbthrift/docs/spec/protocol/interface/rocket"}},d={},m=[{value:"Request",id:"request",level:2},{value:"Serialization Details",id:"serialization-details",level:3},{value:"Response",id:"response",level:2},{value:"Declared Response and Declared Exception",id:"declared-response-and-declared-exception",level:3},{value:"Undeclared Exception",id:"undeclared-exception",level:3},{value:"Any Exception",id:"any-exception",level:3},{value:"Internal Server Error",id:"internal-server-error",level:3},{value:"Interfaces",id:"interfaces",level:2},{value:"Request-Response",id:"request-response",level:3},{value:"Stream",id:"stream",level:3},{value:"Stream Request",id:"stream-request",level:4},{value:"Stream Initial Response",id:"stream-initial-response",level:4},{value:"Stream Payloads",id:"stream-payloads",level:4},{value:"Stream Cancellation",id:"stream-cancellation",level:4},{value:"Stream Completion",id:"stream-completion",level:4},{value:"Stream Flow Control",id:"stream-flow-control",level:4},{value:"Stream Expire Time",id:"stream-expire-time",level:4},{value:"Stream Chunk Timeout",id:"stream-chunk-timeout",level:4},{value:"Sink",id:"sink",level:3},{value:"Sink Request",id:"sink-request",level:4},{value:"Sink Initial Response",id:"sink-initial-response",level:4},{value:"Sink Payloads",id:"sink-payloads",level:4},{value:"Sink Completion",id:"sink-completion",level:4},{value:"Sink Final Response",id:"sink-final-response",level:4},{value:"Sink Flow Control",id:"sink-flow-control",level:4},{value:"Sink Chunk Timeout",id:"sink-chunk-timeout",level:4},{value:"Interactions",id:"interactions",level:3},{value:"Creation",id:"creation",level:4},{value:"Factory Functions",id:"factory-functions",level:5},{value:"Constructors (Deprecated)",id:"constructors-deprecated",level:5},{value:"Termination",id:"termination",level:4},{value:"Serial interactions",id:"serial-interactions",level:4},{value:"Oneway Requests (Deprecated)",id:"oneway-requests-deprecated",level:3},{value:"Timeouts",id:"timeouts",level:2},{value:"Client Timeout",id:"client-timeout",level:3},{value:"Queue Timeout",id:"queue-timeout",level:3},{value:"Compression",id:"compression",level:2},{value:"Request Compression",id:"request-compression",level:3},{value:"Response Compression",id:"response-compression",level:3},{value:"Client Detected Exceptions",id:"client-detected-exceptions",level:2},{value:"Underlying Transport Protocols",id:"underlying-transport-protocols",level:2},{value:"Rocket Protocol",id:"rocket-protocol",level:3},{value:"Header Protocol (Deprecated)",id:"header-protocol-deprecated",level:3}],p={toc:m};function l(e){let{components:t,...n}=e;return(0,a.mdx)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.mdx)("h1",{id:"interface-protocols"},"Interface Protocols"),(0,a.mdx)("p",null,"This document describes the layer immediately preceding the transport protocol (eg. ",(0,a.mdx)("a",{parentName:"p",href:"/fbthrift/docs/spec/protocol/interface/rocket"},"Rocket"),"). This layer specifies how the request/response data must be serialized and formatted before being wrapped in the underlying transport protocol layer's message format."),(0,a.mdx)("h2",{id:"request"},"Request"),(0,a.mdx)("p",null,"The client ",(0,a.mdx)("strong",{parentName:"p"},"must")," take the user provided arguments to the Interface method and serialize the request as described in Serialization Details below. The client ",(0,a.mdx)("strong",{parentName:"p"},"may")," compress the serialized request as described in ",(0,a.mdx)("a",{parentName:"p",href:"#request-compression"},"Request Compression"),". The name of the Interface method being requested as well as the ",(0,a.mdx)("a",{parentName:"p",href:"/fbthrift/docs/spec/protocol/data"},"data protocol")," that was used to serialize the request ",(0,a.mdx)("strong",{parentName:"p"},"must")," be included in the metadata associated with the request. The client may detect an exception while attempting to perform the request before a valid response is received from the server, in which case, it ",(0,a.mdx)("strong",{parentName:"p"},"must")," be raised as a ",(0,a.mdx)("a",{parentName:"p",href:"#client-detected-exceptions"},"Client Detected Exception"),"."),(0,a.mdx)("p",null,"The client ",(0,a.mdx)("strong",{parentName:"p"},"must")," specify the method name in the request as follows:"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},"For methods inside an interaction, the method name is ",(0,a.mdx)("inlineCode",{parentName:"li"},"\u2039InteractionName\u203a.\u2039MethodName\u203a")," where ",(0,a.mdx)("inlineCode",{parentName:"li"},"\u2039InteractionName\u203a")," and ",(0,a.mdx)("inlineCode",{parentName:"li"},"\u2039MethodName\u203a")," are the names in the IDL of the interaction and method respectively."),(0,a.mdx)("li",{parentName:"ul"},"For all other methods (including factory methods for interactions), the method name matches the name in the IDL.")),(0,a.mdx)("h3",{id:"serialization-details"},"Serialization Details"),(0,a.mdx)("p",null,"The parameters to an Interface method ",(0,a.mdx)("strong",{parentName:"p"},"must")," be treated as fields of a Thrift struct with an empty name (",(0,a.mdx)("inlineCode",{parentName:"p"},'""'),"). The Field IDs ",(0,a.mdx)("strong",{parentName:"p"},"must")," be the same as those specified in the IDL. If the Interface method has no parameters then the struct ",(0,a.mdx)("strong",{parentName:"p"},"must")," have no fields. To prepare for sending the request through one of the underlying transport protocols, this unnamed struct ",(0,a.mdx)("strong",{parentName:"p"},"must")," be serialized with one of Thrift\u2019s ",(0,a.mdx)("a",{parentName:"p",href:"/fbthrift/docs/spec/protocol/data"},"data protocols"),"."),(0,a.mdx)("p",null,"For example, this method:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"i32 foo(1: i32 a, 2: string b)\n")),(0,a.mdx)("p",null,"might be called with these fields set in the metadata:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},'  protocol = ProtocolId.COMPACT;\n  name = "foo";\n  kind = RpcKind.SINGLE_REQUEST_SINGLE_RESPONSE;\n  compression = CompressionAlgorithm.ZSTD;\n')),(0,a.mdx)("p",null,"in which case it will have as its serialized request the result of placing the arguments in a"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"struct \u2039Anonymous\u203a {\n  1: i32 a;\n  2: string b;\n}\n")),(0,a.mdx)("p",null,"passing the ",(0,a.mdx)("inlineCode",{parentName:"p"},"\u2039Anonymous\u203a")," to a serializer for the ",(0,a.mdx)("a",{parentName:"p",href:"/fbthrift/docs/spec/protocol/data#compact-protocol"},"Compact Protocol")," and passing the resulting string to a compressor for ",(0,a.mdx)("a",{parentName:"p",href:"https://facebook.github.io/zstd/"},"zstd"),"."),(0,a.mdx)("h2",{id:"response"},"Response"),(0,a.mdx)("p",null,"A response may be one of the following types:"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},"Declared response - responses that actually represent the response type of an Interface declared in the IDL. For example, the return type of a request-response method or the payload type of a stream."),(0,a.mdx)("li",{parentName:"ul"},"Declared exception"),(0,a.mdx)("li",{parentName:"ul"},"Undeclared exception"),(0,a.mdx)("li",{parentName:"ul"},"Any exception"),(0,a.mdx)("li",{parentName:"ul"},"Internal server error")),(0,a.mdx)("p",null,"The server ",(0,a.mdx)("strong",{parentName:"p"},"must")," serialize the response depending on the response type as described below. If the response is a declared response, declared exception, or undeclared exception, the server ",(0,a.mdx)("strong",{parentName:"p"},"should")," compress the serialized response as described in ",(0,a.mdx)("a",{parentName:"p",href:"#response-compression"},"Response Compression"),"."),(0,a.mdx)("h3",{id:"declared-response-and-declared-exception"},"Declared Response and Declared Exception"),(0,a.mdx)("p",null,"The Thrift struct used to represent declared responses and ",(0,a.mdx)("a",{parentName:"p",href:"/fbthrift/docs/spec/definition/exception#exceptions"},"declared exceptions")," ",(0,a.mdx)("strong",{parentName:"p"},"must")," be a union with an empty name (",(0,a.mdx)("inlineCode",{parentName:"p"},'""'),"). The first field in the union with Field ID of ",(0,a.mdx)("inlineCode",{parentName:"p"},"0")," ",(0,a.mdx)("strong",{parentName:"p"},"must")," be for the declared response. If the declared response type is ",(0,a.mdx)("inlineCode",{parentName:"p"},"void")," then the field for the declared response ",(0,a.mdx)("strong",{parentName:"p"},"must")," be skipped. The Thrift struct ",(0,a.mdx)("strong",{parentName:"p"},"must")," also have a field for each declared exception for that Interface with Field IDs matching those specified in the IDL. The correct field ",(0,a.mdx)("strong",{parentName:"p"},"must")," be filled in by the server and then serialized using one of Thrift\u2019s data protocols."),(0,a.mdx)("p",null,"For example, this method:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"i32 foo(1: i32 a, 2: string b) throws (1: MyException e1, 2: OtherException e2);\n")),(0,a.mdx)("p",null,"would use the following union as its response struct:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"union <Anonymous> {\n  0: i32 response;\n  1: MyException e1;\n  2: OtherException e2;\n}\n")),(0,a.mdx)("p",null,"If the response is a declared response, the response metadata ",(0,a.mdx)("strong",{parentName:"p"},"must")," indicate that it is a declared response."),(0,a.mdx)("p",null,"If the response is a declared exception, the response metadata ",(0,a.mdx)("strong",{parentName:"p"},"must")," indicate that it is a declared exception and it ",(0,a.mdx)("strong",{parentName:"p"},"should")," contain a ",(0,a.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift/blob/main/thrift/lib/thrift/RpcMetadata.thrift#ErrorClassification"},(0,a.mdx)("inlineCode",{parentName:"a"},"ErrorClassification"))," struct."),(0,a.mdx)("h3",{id:"undeclared-exception"},"Undeclared Exception"),(0,a.mdx)("p",null,(0,a.mdx)("a",{parentName:"p",href:"/fbthrift/docs/spec/definition/exception#exceptions"},"Undeclared exceptions")," ",(0,a.mdx)("strong",{parentName:"p"},"must")," be sent through the response metadata and the metadata ",(0,a.mdx)("strong",{parentName:"p"},"must")," indicate that the response is an undeclared exception and ",(0,a.mdx)("strong",{parentName:"p"},"must")," contain the exception name and the message."),(0,a.mdx)("h3",{id:"any-exception"},"Any Exception"),(0,a.mdx)("p",null,"The response may also be an Any exception. This is an exception that is serialized using one of Thrift's data protocols and stored in a ",(0,a.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift/blob/main/thrift/lib/thrift/any_rep.thrift#SemiAnyStruct"},(0,a.mdx)("inlineCode",{parentName:"a"},"SemiAnyStruct")),". This ",(0,a.mdx)("inlineCode",{parentName:"p"},"SemiAnyStruct")," then must be serialized using one of Thrift's data protocols. If the protocol used to serialize the exception and the protocol used to serialize the ",(0,a.mdx)("inlineCode",{parentName:"p"},"SemiAnyStruct")," do not match, the ",(0,a.mdx)("inlineCode",{parentName:"p"},"protocol")," field in the ",(0,a.mdx)("inlineCode",{parentName:"p"},"SemiAnyStruct")," ",(0,a.mdx)("strong",{parentName:"p"},"must")," be the data protocol that was used to serialize the exception. The response metadata ",(0,a.mdx)("strong",{parentName:"p"},"must")," indicate that the response is an Any exception."),(0,a.mdx)("h3",{id:"internal-server-error"},"Internal Server Error"),(0,a.mdx)("p",null,"In addition to responses from the server handler, the server can also decide to reject a request for a variety of reasons, for example, load-shedding, invalid request, etc. In this case the server ",(0,a.mdx)("strong",{parentName:"p"},"should")," send an exception containing one of the pre-defined error codes ",(0,a.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift/blob/main/thrift/lib/cpp2/async/ResponseChannel.cpp"},"here"),"."),(0,a.mdx)("h2",{id:"interfaces"},"Interfaces"),(0,a.mdx)("h3",{id:"request-response"},"Request-Response"),(0,a.mdx)("p",null,"To initiate a request-response, the client ",(0,a.mdx)("strong",{parentName:"p"},"must")," make a request for a request-response method defined in the IDL. The request ",(0,a.mdx)("strong",{parentName:"p"},"must")," follow the format defined in ",(0,a.mdx)("a",{parentName:"p",href:"#request"},"Request"),". After sending the request, the client ",(0,a.mdx)("strong",{parentName:"p"},"should")," wait for a response from the server or throw a ",(0,a.mdx)("a",{parentName:"p",href:"#client-detected-exceptions"},"Client Detected Exception"),"."),(0,a.mdx)("p",null,"The server ",(0,a.mdx)("strong",{parentName:"p"},"must")," execute the server handler for the requested method or reject the request with an ",(0,a.mdx)("a",{parentName:"p",href:"#internal-server-error"},"internal server error"),". Once the server handler finishes executing or throws an exception, the response ",(0,a.mdx)("strong",{parentName:"p"},"must")," be sent using the format defined in ",(0,a.mdx)("a",{parentName:"p",href:"#response"},"Response"),"."),(0,a.mdx)("h3",{id:"stream"},"Stream"),(0,a.mdx)("h4",{id:"stream-request"},"Stream Request"),(0,a.mdx)("p",null,"To initiate a stream, the client ",(0,a.mdx)("strong",{parentName:"p"},"must")," make a request for a stream method defined in the IDL. The request ",(0,a.mdx)("strong",{parentName:"p"},"must")," follow the format defined in ",(0,a.mdx)("a",{parentName:"p",href:"#request"},"Request"),". After sending the request, the client ",(0,a.mdx)("strong",{parentName:"p"},"should")," wait for a response from the server or throw a ",(0,a.mdx)("a",{parentName:"p",href:"#client-detected-exceptions"},"Client Detected Exception"),"."),(0,a.mdx)("h4",{id:"stream-initial-response"},"Stream Initial Response"),(0,a.mdx)("p",null,"The server ",(0,a.mdx)("strong",{parentName:"p"},"must")," execute the server handler for the stream method or reject the request with an ",(0,a.mdx)("a",{parentName:"p",href:"#internal-server-error"},"internal server error"),". If the server handler finishes executing successfully, the server ",(0,a.mdx)("strong",{parentName:"p"},"must")," send an initial response to the client containing the initial response type specified in the IDL (assumed to be ",(0,a.mdx)("inlineCode",{parentName:"p"},"void")," if no initial response type is specified). This initial response ",(0,a.mdx)("strong",{parentName:"p"},"must")," be formatted as specified in ",(0,a.mdx)("a",{parentName:"p",href:"#response"},"Response")," and will establish the stream."),(0,a.mdx)("p",null,"If the request was rejected with an ",(0,a.mdx)("a",{parentName:"p",href:"#internal-server-error"},"internal server error")," or the server handler threw an exception (declared or undeclared) the stream ",(0,a.mdx)("strong",{parentName:"p"},"must not")," be established and the error ",(0,a.mdx)("strong",{parentName:"p"},"must")," be sent to the client using the format specified in ",(0,a.mdx)("a",{parentName:"p",href:"#response"},"Response"),". In this case, the server ",(0,a.mdx)("strong",{parentName:"p"},"must not")," send any stream payloads to the client."),(0,a.mdx)("h4",{id:"stream-payloads"},"Stream Payloads"),(0,a.mdx)("p",null,"Once the initial response is sent and the server has credits, the server ",(0,a.mdx)("strong",{parentName:"p"},"should")," start sending stream payloads to the client. The stream payloads ",(0,a.mdx)("strong",{parentName:"p"},"must")," be an actual payload, a declared exception, or an undeclared exception and they follow the format of these response types as defined in ",(0,a.mdx)("a",{parentName:"p",href:"#response"},"Response"),"."),(0,a.mdx)("p",null,"If the server sends a declared exception or an undeclared exception to the client, it acts as the termination of the stream and the server ",(0,a.mdx)("strong",{parentName:"p"},"must not")," send any more payloads to the client."),(0,a.mdx)("h4",{id:"stream-cancellation"},"Stream Cancellation"),(0,a.mdx)("p",null,"The client ",(0,a.mdx)("strong",{parentName:"p"},"may")," send a cancellation signal to the server at any point after the stream is established. If the server receives a cancellation, it ",(0,a.mdx)("strong",{parentName:"p"},"should")," stop sending stream payloads to the client."),(0,a.mdx)("h4",{id:"stream-completion"},"Stream Completion"),(0,a.mdx)("p",null,"If the stream was established, the server ",(0,a.mdx)("strong",{parentName:"p"},"must")," send a completion signal to the client once it is done sending all stream payloads to the client. The completion signal acts as a termination of the stream and the server ",(0,a.mdx)("strong",{parentName:"p"},"must not")," send any payloads to the client after it has sent the completion signal."),(0,a.mdx)("h4",{id:"stream-flow-control"},"Stream Flow Control"),(0,a.mdx)("p",null,"Thrift streaming ",(0,a.mdx)("strong",{parentName:"p"},"must")," be flow-controlled using a credit mechanism. The client ",(0,a.mdx)("strong",{parentName:"p"},"must")," give the server an initial set of credits that the server can use to send stream payloads. Each stream payload ",(0,a.mdx)("strong",{parentName:"p"},"must")," consume one credit on the server. The server ",(0,a.mdx)("strong",{parentName:"p"},"must not")," send any payloads if it has no credits until it receives more from the client."),(0,a.mdx)("h4",{id:"stream-expire-time"},"Stream Expire Time"),(0,a.mdx)("p",null,"The server ",(0,a.mdx)("strong",{parentName:"p"},"may")," specify a stream expire time which is the time the server ",(0,a.mdx)("strong",{parentName:"p"},"should")," wait after exhausting all of its credits to receive more credits from the client. If the server doesn\u2019t receive any credits after the stream expire time has elapsed, the server ",(0,a.mdx)("strong",{parentName:"p"},"should")," terminate the stream with an ",(0,a.mdx)("a",{parentName:"p",href:"#internal-server-error"},"internal server error"),"."),(0,a.mdx)("h4",{id:"stream-chunk-timeout"},"Stream Chunk Timeout"),(0,a.mdx)("p",null,"The client ",(0,a.mdx)("strong",{parentName:"p"},"may")," specify a chunk timeout which is the time the client ",(0,a.mdx)("strong",{parentName:"p"},"should")," wait for receiving a new stream payload from the server. If the client doesn\u2019t receive a payload from the server for longer than the chunk timeout, it ",(0,a.mdx)("strong",{parentName:"p"},"should")," cancel the stream and raise a ",(0,a.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift/blob/main/thrift/lib/cpp/transport/TTransportException.h"},(0,a.mdx)("inlineCode",{parentName:"a"},"TTransportException"))," with the type ",(0,a.mdx)("inlineCode",{parentName:"p"},"TIMEOUT"),"."),(0,a.mdx)("h3",{id:"sink"},"Sink"),(0,a.mdx)("h4",{id:"sink-request"},"Sink Request"),(0,a.mdx)("p",null,"To initiate a sink, the client ",(0,a.mdx)("strong",{parentName:"p"},"must")," make a request for a sink method defined in the IDL. The request ",(0,a.mdx)("strong",{parentName:"p"},"must")," follow the format defined in ",(0,a.mdx)("a",{parentName:"p",href:"#request"},"Request"),". After sending the request, the client ",(0,a.mdx)("strong",{parentName:"p"},"should")," wait for a response from the server or throw a ",(0,a.mdx)("a",{parentName:"p",href:"#client-detected-exceptions"},"Client Detected Exception"),"."),(0,a.mdx)("h4",{id:"sink-initial-response"},"Sink Initial Response"),(0,a.mdx)("p",null,"The server ",(0,a.mdx)("strong",{parentName:"p"},"must")," execute the server handler for the sink method or reject the request with an ",(0,a.mdx)("a",{parentName:"p",href:"#internal-server-error"},"internal server error"),". If the server handler finishes executing successfully, the server ",(0,a.mdx)("strong",{parentName:"p"},"must")," send an initial response to the client containing the initial response type specified in the IDL (assumed to be ",(0,a.mdx)("inlineCode",{parentName:"p"},"void")," if no initial response type is specified). This initial response ",(0,a.mdx)("strong",{parentName:"p"},"must")," be formatted as specified in ",(0,a.mdx)("a",{parentName:"p",href:"#response"},"Response")," and will establish the sink."),(0,a.mdx)("p",null,"If the request was rejected with an ",(0,a.mdx)("a",{parentName:"p",href:"#internal-server-error"},"internal server error")," or the server handler threw an exception (declared or undeclared) the sink ",(0,a.mdx)("strong",{parentName:"p"},"must not")," be established and the error ",(0,a.mdx)("strong",{parentName:"p"},"must")," be sent to the client using the format specified in #Response. In this case, the client ",(0,a.mdx)("strong",{parentName:"p"},"must not")," send any sink payloads to the server and the server ",(0,a.mdx)("strong",{parentName:"p"},"must not")," send a final response to the client."),(0,a.mdx)("h4",{id:"sink-payloads"},"Sink Payloads"),(0,a.mdx)("p",null,"Once the initial response is received and the client has received an initial set of credits from the server, the client ",(0,a.mdx)("strong",{parentName:"p"},"should")," start sending sink payloads to the server. The sink payloads ",(0,a.mdx)("strong",{parentName:"p"},"must")," be an actual payload, a declared exception, or an undeclared exception and they follow the serialization format of these response types as defined in ",(0,a.mdx)("a",{parentName:"p",href:"#response"},"Response"),"."),(0,a.mdx)("p",null,"If the client sends a declared exception or an undeclared exception to the server, it ",(0,a.mdx)("strong",{parentName:"p"},"must not")," send any more payloads to the server. The server ",(0,a.mdx)("strong",{parentName:"p"},"may")," still respond with a final response."),(0,a.mdx)("h4",{id:"sink-completion"},"Sink Completion"),(0,a.mdx)("p",null,"If the sink was established, the client ",(0,a.mdx)("strong",{parentName:"p"},"must")," send a completion signal to the server once it is done sending all sink payloads to the server. The client ",(0,a.mdx)("strong",{parentName:"p"},"must not")," send any payloads to the server after it has sent the completion signal."),(0,a.mdx)("h4",{id:"sink-final-response"},"Sink Final Response"),(0,a.mdx)("p",null,"If the sink was established, the server ",(0,a.mdx)("strong",{parentName:"p"},"must")," send a final response to the client. The final response acts as a termination of the sink. The final response ",(0,a.mdx)("strong",{parentName:"p"},"may")," be any one of the response types mentioned in ",(0,a.mdx)("a",{parentName:"p",href:"#response"},"Response"),". The server ",(0,a.mdx)("strong",{parentName:"p"},"may")," send this final response before it receives the completion signal from the client."),(0,a.mdx)("h4",{id:"sink-flow-control"},"Sink Flow Control"),(0,a.mdx)("p",null,"Thrift sinks ",(0,a.mdx)("strong",{parentName:"p"},"must")," be flow-controlled using a credit mechanism. The server ",(0,a.mdx)("strong",{parentName:"p"},"must")," send the client an initial set of credits after it receives a sink request. Each sink payload ",(0,a.mdx)("strong",{parentName:"p"},"must")," consume one credit on the client. The client ",(0,a.mdx)("strong",{parentName:"p"},"must not")," send any payloads if it has no credits until it receives more from the server."),(0,a.mdx)("h4",{id:"sink-chunk-timeout"},"Sink Chunk Timeout"),(0,a.mdx)("p",null,"The server ",(0,a.mdx)("strong",{parentName:"p"},"may")," specify a chunk timeout which is the time the server ",(0,a.mdx)("strong",{parentName:"p"},"should")," wait for receiving a new sink payload from the client. If the server doesn\u2019t receive a payload from the client for longer than the chunk timeout, it ",(0,a.mdx)("strong",{parentName:"p"},"should")," terminate the sink by sending an ",(0,a.mdx)("a",{parentName:"p",href:"#internal-server-error"},"internal server error"),"."),(0,a.mdx)("h3",{id:"interactions"},"Interactions"),(0,a.mdx)("p",null,"Requests that are part of the interaction ",(0,a.mdx)("strong",{parentName:"p"},"must")," be sent over the same connection to the server. Each interaction ",(0,a.mdx)("strong",{parentName:"p"},"must")," have an ID that is unique to the connection. The server ",(0,a.mdx)("strong",{parentName:"p"},"must")," maintain the state that is associated with each interaction so that subsequent requests can use that state."),(0,a.mdx)("p",null,"All requests in an interaction, including the factory function if used, ",(0,a.mdx)("strong",{parentName:"p"},"must")," reach the server in the order they are sent by the client. The server ",(0,a.mdx)("strong",{parentName:"p"},"may")," begin processing subsequent requests before the earlier ones complete, provided they are started in order."),(0,a.mdx)("p",null,"The RPC contracts of member requests are otherwise handled the same as if the requests were not in an interaction. A single interaction ",(0,a.mdx)("strong",{parentName:"p"},"may")," include multiple streams/sinks, and these are flow-controlled independently."),(0,a.mdx)("h4",{id:"creation"},"Creation"),(0,a.mdx)("p",null,"Interactions can be created in two different ways as described below."),(0,a.mdx)("h5",{id:"factory-functions"},"Factory Functions"),(0,a.mdx)("p",null,"Factory functions are an eager way to create an interaction, in that the interaction is created when the factory function is called. The factory function request ",(0,a.mdx)("strong",{parentName:"p"},"must")," have metadata indicating that it is creating an interaction. The server ",(0,a.mdx)("strong",{parentName:"p"},"must")," execute the server handler for the factory function or reject the request with an ",(0,a.mdx)("a",{parentName:"p",href:"#internal-server-error"},"internal server error"),". If the server handler finishes executing successfully, the server ",(0,a.mdx)("strong",{parentName:"p"},"must")," send a response to the client containing the response type specified in the IDL (assumed to be ",(0,a.mdx)("inlineCode",{parentName:"p"},"void")," if no response type is specified). Subsequent requests in the interaction ",(0,a.mdx)("strong",{parentName:"p"},"must")," contain the interaction ID in their metadata."),(0,a.mdx)("h5",{id:"constructors-deprecated"},"Constructors (Deprecated)"),(0,a.mdx)("p",null,"Interaction constructors are a lazy way to create an interaction, in that the interaction is not created until the first request that is part of the interaction is sent. This first request ",(0,a.mdx)("strong",{parentName:"p"},"must")," have metadata indicating that it is the first request. Subsequent requests ",(0,a.mdx)("strong",{parentName:"p"},"must")," contain the interaction ID in their metadata."),(0,a.mdx)("h4",{id:"termination"},"Termination"),(0,a.mdx)("p",null,"Only the client can terminate the interaction and it can do so at any time after the interaction has been created, including with requests outstanding. When an interaction is terminated, the client ",(0,a.mdx)("strong",{parentName:"p"},"must")," send a termination signal to the server. The server ",(0,a.mdx)("strong",{parentName:"p"},"must")," finish processing any outstanding requests when the termination signal is received, including waiting for streams/sinks to complete normally; terminating an interaction ",(0,a.mdx)("strong",{parentName:"p"},"must not")," cancel member streams/sinks. The server ",(0,a.mdx)("strong",{parentName:"p"},"must")," invoke the following two hooks:"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},"onTermination: scheduled immediately when termination signal is received, without waiting for outstanding requests to complete."),(0,a.mdx)("li",{parentName:"ul"},"destructor: scheduled once all responses have been sent back to the client and streams/sinks completed.")),(0,a.mdx)("h4",{id:"serial-interactions"},"Serial interactions"),(0,a.mdx)("p",null,"For interactions annotated ",(0,a.mdx)("inlineCode",{parentName:"p"},"(serial)")," the server ",(0,a.mdx)("strong",{parentName:"p"},"must")," ensure no more than one request is being executed at a time by buffering concurrent requests and executing them sequentially. The client ",(0,a.mdx)("strong",{parentName:"p"},"may")," send multiple requests in such an interaction without waiting for responses in between."),(0,a.mdx)("h3",{id:"oneway-requests-deprecated"},"Oneway Requests (Deprecated)"),(0,a.mdx)("p",null,"To perform a oneway request, the client ",(0,a.mdx)("strong",{parentName:"p"},"must")," make a request for a oneway request method defined in the IDL. The request ",(0,a.mdx)("strong",{parentName:"p"},"must")," follow the format defined in ",(0,a.mdx)("a",{parentName:"p",href:"#request"},"Request"),". The client ",(0,a.mdx)("strong",{parentName:"p"},"must not")," wait for a response from the server. The client ",(0,a.mdx)("strong",{parentName:"p"},"should")," raise a ",(0,a.mdx)("a",{parentName:"p",href:"#client-detected-exceptions"},"Client Detected Exception")," if there is an exception while the client is attempting to send the request. The server ",(0,a.mdx)("strong",{parentName:"p"},"must")," execute the server handler for the requested method or drop the request."),(0,a.mdx)("h2",{id:"timeouts"},"Timeouts"),(0,a.mdx)("h3",{id:"client-timeout"},"Client Timeout"),(0,a.mdx)("p",null,"The client ",(0,a.mdx)("strong",{parentName:"p"},"may")," specify a timeout value for a request which is the amount of time it is willing to wait for a response from the server before giving up and raising a ",(0,a.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift/blob/main/thrift/lib/cpp/transport/TTransportException.h"},(0,a.mdx)("inlineCode",{parentName:"a"},"TTransportException"))," with the type ",(0,a.mdx)("inlineCode",{parentName:"p"},"TIMEOUT"),". This timeout value ",(0,a.mdx)("strong",{parentName:"p"},"should")," also be sent to the server in the request metadata. If set, the server ",(0,a.mdx)("strong",{parentName:"p"},"should")," only start processing the request from the request queue if the client timeout has not already expired. If it has already expired, the server ",(0,a.mdx)("strong",{parentName:"p"},"should")," instead drop the request and send an ",(0,a.mdx)("a",{parentName:"p",href:"#internal-server-error"},"internal server error")," with the code ",(0,a.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift/blob/main/thrift/lib/cpp2/async/ResponseChannel.cpp"},(0,a.mdx)("inlineCode",{parentName:"a"},"kTaskExpiredErrorCode")),"."),(0,a.mdx)("h3",{id:"queue-timeout"},"Queue Timeout"),(0,a.mdx)("p",null,"The client ",(0,a.mdx)("strong",{parentName:"p"},"may")," specify a queue timeout value in the request metadata. The queue timeout is the amount of time the server ",(0,a.mdx)("strong",{parentName:"p"},"should")," allow the request to sit in its request queue before giving up and dropping the request. If the request sits in the request queue for longer than the queue timeout value, the server ",(0,a.mdx)("strong",{parentName:"p"},"should not")," start processing the request and instead send an ",(0,a.mdx)("a",{parentName:"p",href:"#internal-server-error"},"internal server error")," with the code ",(0,a.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift/blob/main/thrift/lib/cpp2/async/ResponseChannel.cpp"},(0,a.mdx)("inlineCode",{parentName:"a"},"kServerQueueTimeoutErrorCode")),"."),(0,a.mdx)("h2",{id:"compression"},"Compression"),(0,a.mdx)("p",null,"Request and response compression is supported in Thrift using one of the following algorithms:"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},"ZLIB"),(0,a.mdx)("li",{parentName:"ul"},"ZSTD")),(0,a.mdx)("h3",{id:"request-compression"},"Request Compression"),(0,a.mdx)("p",null,"Requests ",(0,a.mdx)("strong",{parentName:"p"},"may")," be compressed by the client after they have been serialized as described in #Request-serialization. If the request was compressed, the compression algorithm ",(0,a.mdx)("strong",{parentName:"p"},"must")," be specified in the request metadata."),(0,a.mdx)("h3",{id:"response-compression"},"Response Compression"),(0,a.mdx)("p",null,"The client ",(0,a.mdx)("strong",{parentName:"p"},"may")," request the server to compress responses based on the size of the response. If requesting compression, the client ",(0,a.mdx)("strong",{parentName:"p"},"should")," specify the compression algorithm and the minimum response size that ",(0,a.mdx)("strong",{parentName:"p"},"should")," trigger compression in the request metadata. If requested by the client, the server ",(0,a.mdx)("strong",{parentName:"p"},"should")," compress the response after it has been serialized using the compression algorithm specified by the client. If not requested by the client, the server ",(0,a.mdx)("strong",{parentName:"p"},"may")," compress the response and it ",(0,a.mdx)("strong",{parentName:"p"},"may")," use any supported compression algorithm. If the response was compressed, the compression algorithm ",(0,a.mdx)("strong",{parentName:"p"},"must")," be specified in the response metadata."),(0,a.mdx)("h2",{id:"client-detected-exceptions"},"Client Detected Exceptions"),(0,a.mdx)("p",null,"Exceptions that are detected purely by the client (rather than being sent over the wire from the server) are represented as ",(0,a.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift/blob/main/thrift/lib/cpp/transport/TTransportException.h"},(0,a.mdx)("inlineCode",{parentName:"a"},"TTransportException")),". Some of the reasons why a client detected exception may be raised include:"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},"Timeout (server non-responsive)"),(0,a.mdx)("li",{parentName:"ul"},"Corrupted data (checksum mismatch)"),(0,a.mdx)("li",{parentName:"ul"},"Socket errors"),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("a",{parentName:"li",href:"https://github.com/facebook/fbthrift/blob/main/thrift/lib/cpp/transport/TTransportException.h#TTransportExceptionType"},"Many more"))),(0,a.mdx)("h2",{id:"underlying-transport-protocols"},"Underlying Transport Protocols"),(0,a.mdx)("p",null,"The Thrift Interface protocol is a higher level abstraction that defines the behavior of various interfaces, however, it must utilize a lower level transport protocol to actually send requests and receive responses."),(0,a.mdx)("h3",{id:"rocket-protocol"},"Rocket Protocol"),(0,a.mdx)("p",null,(0,a.mdx)("a",{parentName:"p",href:"/fbthrift/docs/spec/protocol/interface/rocket"},"Rocket protocol")," is an implementation of the Thrift Interface protocol using the ",(0,a.mdx)("a",{parentName:"p",href:"https://rsocket.io/"},"RSocket protocol"),"."),(0,a.mdx)("h3",{id:"header-protocol-deprecated"},"Header Protocol (Deprecated)"),(0,a.mdx)("p",null,"Header protocol is a deprecated transport protocol."))}l.isMDXComponent=!0}}]);