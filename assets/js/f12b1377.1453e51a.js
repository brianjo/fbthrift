"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6575],{3905:(e,t,r)=>{r.r(t),r.d(t,{MDXContext:()=>p,MDXProvider:()=>s,mdx:()=>b,useMDXComponents:()=>c,withMDXComponents:()=>m});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},i.apply(this,arguments)}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function d(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var p=n.createContext({}),m=function(e){return function(t){var r=c(t.components);return n.createElement(e,i({},t,{components:r}))}},c=function(e){var t=n.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},s=function(e){var t=c(e.components);return n.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,p=d(e,["components","mdxType","originalType","parentName"]),m=c(r),s=a,f=m["".concat(o,".").concat(s)]||m[s]||u[s]||i;return r?n.createElement(f,l(l({ref:t},p),{},{components:r})):n.createElement(f,l({ref:t},p))}));function b(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=f;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var p=2;p<i;p++)o[p]=r[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},33765:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var n=r(83117),a=(r(67294),r(3905));const i={},o="Tolerance",l={unversionedId:"spec/definition/tolerance",id:"spec/definition/tolerance",title:"Tolerance",description:"This category of conformance describes the expected behavior when a reader reads malformed data. It describes what type of behavior is expected when malformed data is encountered. It is important to verify that these cases are handled gracefully in all Thrift implementations as serialized data may be unintentionally or intentionally altered before deserialization.",source:"@site/../doc/spec/definition/tolerance.md",sourceDirName:"spec/definition",slug:"/spec/definition/tolerance",permalink:"/docs/spec/definition/tolerance",draft:!1,editUrl:"https://github.com/facebook/fbthrift/blob/main/thrift/website/../doc/spec/definition/tolerance.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Programs",permalink:"/docs/spec/definition/program"},next:{title:"Values",permalink:"/docs/spec/definition/value"}},d={},p=[{value:"Behaviors",id:"behaviors",level:2},{value:"Cases",id:"cases",level:2}],m={toc:p};function c(e){let{components:t,...r}=e;return(0,a.mdx)("wrapper",(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,a.mdx)("h1",{id:"tolerance"},"Tolerance"),(0,a.mdx)("p",null,"This category of conformance describes the expected behavior when a reader reads malformed data. It describes what type of behavior is expected when malformed data is encountered. It is important to verify that these cases are handled gracefully in all Thrift implementations as serialized data may be unintentionally or intentionally altered before deserialization."),(0,a.mdx)("h2",{id:"behaviors"},"Behaviors"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},"Exception: ProtocolException will be thrown."),(0,a.mdx)("li",{parentName:"ul"},"Corrupted data: Reader returns data that might be different from what's serialized."),(0,a.mdx)("li",{parentName:"ul"},"Exception or corrupted data: Either ProtocolException will be thrown, or reader returns incorrect data.")),(0,a.mdx)("h2",{id:"cases"},"Cases"),(0,a.mdx)("table",null,(0,a.mdx)("thead",{parentName:"table"},(0,a.mdx)("tr",{parentName:"thead"},(0,a.mdx)("th",{parentName:"tr",align:null},"Issue"),(0,a.mdx)("th",{parentName:"tr",align:null},"Result"))),(0,a.mdx)("tbody",{parentName:"table"},(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},"Incorrect length for containers"),(0,a.mdx)("td",{parentName:"tr",align:null},"Exception or corrupted data")),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},"Empty varint bytes"),(0,a.mdx)("td",{parentName:"tr",align:null},"Exception or corrupted data")),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},"Unknown type"),(0,a.mdx)("td",{parentName:"tr",align:null},"Exception")),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},"Multiple equivalent set values"),(0,a.mdx)("td",{parentName:"tr",align:null},"Corrupted data")),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},"Multiple equal set values"),(0,a.mdx)("td",{parentName:"tr",align:null},"Corrupted data")),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},"Multiple equivalent map keys"),(0,a.mdx)("td",{parentName:"tr",align:null},"Corrupted data")),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},"Multiple equal map keys"),(0,a.mdx)("td",{parentName:"tr",align:null},"Corrupted data")),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},"Out of range for integer"),(0,a.mdx)("td",{parentName:"tr",align:null},"Exception")),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},"Invalid UTF-8 in string field"),(0,a.mdx)("td",{parentName:"tr",align:null},"Exception")),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},"Union with multiple fields set"),(0,a.mdx)("td",{parentName:"tr",align:null},"Exception")))))}c.isMDXComponent=!0}}]);