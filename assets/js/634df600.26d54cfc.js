"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9339],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>c,MDXProvider:()=>h,mdx:()=>f,useMDXComponents:()=>d,withMDXComponents:()=>p});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},i.apply(this,arguments)}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),p=function(e){return function(t){var n=d(t.components);return a.createElement(e,i({},t,{components:n}))}},d=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},h=function(e){var t=d(e.components);return a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=d(n),h=r,u=p["".concat(o,".").concat(h)]||p[h]||m[h]||i;return n?a.createElement(u,s(s({ref:t},c),{},{components:n})):a.createElement(u,s({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},29115:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(83117),r=(n(67294),n(3905));const i={state:"draft"},o="Channels",s={unversionedId:"spec/protocol/channel",id:"spec/protocol/channel",title:"Channels",description:"The channel is the interface to Thrift RPC in each target language. While channels exist on both client and server, the term by itself commonly refers to the client channel. Here, the client and server are the two parties to the RPC where the client is the initiator.",source:"@site/../doc/spec/protocol/channel.md",sourceDirName:"spec/protocol",slug:"/spec/protocol/channel",permalink:"/fbthrift/docs/spec/protocol/channel",draft:!1,editUrl:"https://github.com/facebook/fbthrift/blob/main/thrift/website/../doc/spec/protocol/channel.md",tags:[],version:"current",frontMatter:{state:"draft"},sidebar:"sidebar",previous:{title:"Protocols",permalink:"/fbthrift/docs/spec/protocol/"},next:{title:"Data Protocols",permalink:"/fbthrift/docs/spec/protocol/data"}},l={},c=[{value:"Structure",id:"structure",level:2},{value:"Interface",id:"interface",level:2},{value:"Typed channel",id:"typed-channel",level:3},{value:"Untyped channel",id:"untyped-channel",level:3},{value:"RpcOptions",id:"rpcoptions",level:4},{value:"Metadata",id:"metadata",level:4},{value:"SerializedRequest",id:"serializedrequest",level:4},{value:"Response",id:"response",level:4},{value:"Interactions",id:"interactions",level:2},{value:"Ordering",id:"ordering",level:2}],p={toc:c};function d(e){let{components:t,...n}=e;return(0,r.mdx)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.mdx)("h1",{id:"channels"},"Channels"),(0,r.mdx)("p",null,"The ",(0,r.mdx)("em",{parentName:"p"},"channel")," is the interface to Thrift RPC in each target language. While channels exist on both client and server, the term by itself commonly refers to the client channel. Here, the client and server are the two parties to the RPC where the client is the initiator.\nA client channel is bound to a conceptual group of server channels that can respond to RPCs (e.g. a service or library instance). There may or may not be one or more remote hosts that requests can be routed to, or an in-process handler. An interface may return a client channel (by adapting a struct with instructions for creating it) to delegate future RPCs to a different service.\nThe concept of a channel does not have any relation to TCP or other connections to the server. Channel implementations might own or share ownership of one or several connections, might own no connections (opening them as needed or using an external pool), or might be communicating to an in-memory server without any connections involved."),(0,r.mdx)("h1",{id:"client-channel"},"Client channel"),(0,r.mdx)("h2",{id:"structure"},"Structure"),(0,r.mdx)("p",null,"Users of a thrift service typically interact with a \u201cgenerated client\u201d, which is a native object in each target language on which service methods are called in a strongly-typed way. To avoid confusion, this document will call this \u201cgenerated client\u201d a ",(0,r.mdx)("em",{parentName:"p"},"typed client channel"),". The typed channel is a friendly interface that allows the target language to typecheck, autocomplete, and otherwise provide developer functionality. It ",(0,r.mdx)("strong",{parentName:"p"},"should")," wrap an ",(0,r.mdx)("em",{parentName:"p"},"untyped client channel"),", which is a class responsible for implementing the mechanics of RPC. The typed channel is just responsible for type erasure via serializing the arguments and method info and deserializing the response and for interfacing with the native asynchrony primitives. Following this structure provides the best experience for users of the thrift implementation while minimizing the complexity of the generated code. Further, target language implementations of the ",(0,r.mdx)("em",{parentName:"p"},"untyped client channel")," ",(0,r.mdx)("strong",{parentName:"p"},"should")," wrap the ",(0,r.mdx)("a",{parentName:"p",href:"../../cpp/channel"},"C++ implementation")," whenever technically feasible, as direct implementation is involved and carries a significant ongoing maintenance burden."),(0,r.mdx)("h2",{id:"interface"},"Interface"),(0,r.mdx)("h3",{id:"typed-channel"},"Typed channel"),(0,r.mdx)("p",null,"The typed channel is responsible for the core abstraction of RPC, namely that the client is calling a regular method in its native language. It should be a native class/object with one or more methods corresponding to each method in the service.\nEach method may have multiple overloads for supporting the optional RpcOptions argument and different asynchrony models (including blocking if desired). The target language\u2019s idiomatic awaitable type should be used in at least one of the options, when applicable.\nThe methods should have an argument list that corresponds to that of the method in the IDL, accepting native and generated types.\nThe typed channel must support four kinds of methods. The return types are specified below, using the following placeholders:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"ResponseType, PayloadType, FinalResponseType: data types"),(0,r.mdx)("li",{parentName:"ul"},"Awaitable: the target language's native primitive for asynchronous return values (e.g. Future, Awaitable)"),(0,r.mdx)("li",{parentName:"ul"},"Generator: the target language's native primitive for asynchronous streams of values (e.g. AsyncGenerator, Flowable)")),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},"Request-response: Awaitable\u2039ResponseType\u203a"),(0,r.mdx)("li",{parentName:"ol"},"Request-no-response: Awaitable\u2039void\u203a completed when the request is sent or enqueued for sending. May also return void synchronously when only enqueuing is known and is always synchronous."),(0,r.mdx)("li",{parentName:"ol"},"Stream: Awaitable\u2039ResponseType, Generator\u2039PayloadType\u203a\u203a\nThis kind of method behaves like a request-response RPC that returns a generator of values alongside the initial response. This generator asynchrously produces values until either the client cancels the stream or the server completes it.\nThis native primitive must expose a mechanism for requesting cancellation (e.g. destruction or a method call).\nThe stream is flow-controlled on a payload basis, and the native primitive should support propagating backpressure from the application level by requesting more payloads as the application consumes its internal buffer."),(0,r.mdx)("li",{parentName:"ol"},"Sink: Awaitable\u2039ResponseType, (Generator\u2039PayloadType\u203a\u2192Awaitable\u2039FinalResponseType\u203a)\u203a\nThis kind of method behaves like a request-response RPC that returns a (functor that accepts a generator of values and asynchronously returns an additional response) alongside the initial response.\nThe caller passes its generator (again a native primitive like AsyncGenerator or Flowable) to the functor, which drives the generator and sends the produced payloads to the server until the generator completes or the server sends its final response. When the final response is received before the generator completes, the generator is destroyed without being completed.\nThe stream is flow-controlled on a payload basis, and the functor (part of the Thrift implementation in the target language) is responsible for respecting this flow control.")),(0,r.mdx)("p",null,"Metadata / headers may be attached to any payload in any of these requests.\nAny of these method kinds except oneway / request-no-response can also create ",(0,r.mdx)("a",{parentName:"p",href:"#interactions"},"Interactions")),(0,r.mdx)("p",null,"The typed channel\u2019s methods should arguments corresponding to those declared in the IDL, as well as an optional first argument of type ",(0,r.mdx)("a",{parentName:"p",href:"#rpcoptions"},"RpcOptions")," which the typed channel copies and sets the interaction id on if applicable and passes through to the untyped channel."),(0,r.mdx)("h3",{id:"untyped-channel"},"Untyped channel"),(0,r.mdx)("p",null,"The untyped channel has a structure corresponding to this schema:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"service UntypedChannel {\n  binary sendRequestResponse(\n    1: RpcOptions options,\n    2: RequestRpcMetadata metadata,\n    3: binary serializedRequest\n  )\n  oneway void sendRequestNoResponse(\n    1: RpcOptions options,\n    2: RequestRpcMetadata metadata,\n    3: binary serializedRequest\n  )\n  binary, stream<binary> sendRequestStream(\n    1: RpcOptions options,\n    2: RequestRpcMetadata metadata,\n    3: binary serializedRequest\n  )\n  binary, sink<binary, binary> sendRequestSink(\n    1: RpcOptions options,\n    2: RequestRpcMetadata metadata,\n    3: binary serializedRequest\n  )\n\n  InteractionId createInteraction(1: string name)\n  void terminateInteraction(1: InteractionId id)\n}\n")),(0,r.mdx)("p",null,"Implementations have freedom with bridging to their language's async primitives. For example, all methods in C++ return void and take a callback parameter that receives the return type."),(0,r.mdx)("h4",{id:"rpcoptions"},"RpcOptions"),(0,r.mdx)("p",null,"Existing implementations use this to set some per-request options like timeouts and stream buffer size. Unless using ",(0,r.mdx)("a",{parentName:"p",href:"#interactions"},"Interactions"),", all fields are optional. Potentially relevant fields are documented ",(0,r.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift/blob/main/thrift/lib/cpp2/async/RpcOptions.h"},"inline")),(0,r.mdx)("h4",{id:"metadata"},"Metadata"),(0,r.mdx)("p",null,"Documented ",(0,r.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift/blob/main/thrift/lib/thrift/RpcMetadata.thrift"},"inline"),"\nNote the first few fields are mandatory:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Protocol used to serialize the request body (compact/binary)"),(0,r.mdx)("li",{parentName:"ul"},"Compression used on serialized request, if applicable (zlib / zstd)"),(0,r.mdx)("li",{parentName:"ul"},"Method name and kind")),(0,r.mdx)("p",null,"Common other fields:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"timeouts (queue and overall)"),(0,r.mdx)("li",{parentName:"ul"},"unstructured headers (string to string map)"),(0,r.mdx)("li",{parentName:"ul"},"checksum")),(0,r.mdx)("h4",{id:"serializedrequest"},"SerializedRequest"),(0,r.mdx)("p",null,"Method arguments wrapped in an anonymous struct and serialized as described in the ",(0,r.mdx)("a",{parentName:"p",href:"/fbthrift/docs/spec/protocol/interface/#serialization-details"},"interface spec"),"."),(0,r.mdx)("h4",{id:"response"},"Response"),(0,r.mdx)("p",null,"A serialized response is received for all methods except oneway (including void-returning methods) that may contain a serialized representation of the declared response type, one of the exceptions declared in the ",(0,r.mdx)("inlineCode",{parentName:"p"},"throws")," list of the method, or a ",(0,r.mdx)("inlineCode",{parentName:"p"},"TApplicationException")," for undeclared exceptions. In case of exception, the following information will be placed in the unstructured response headers:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"\u2018ex\u2019 : an error code from ",(0,r.mdx)("a",{parentName:"li",href:"https://github.com/facebook/fbthrift/blob/main/thrift/lib/cpp2/async/ResponseChannel.cpp"},"this list")),(0,r.mdx)("li",{parentName:"ul"},"\u2018uex\u2019: the type name of the exception"),(0,r.mdx)("li",{parentName:"ul"},"\u2018uexw\u2019: a description of the exception")),(0,r.mdx)("p",null,"If the exception comes from the second hop of a proxied request a \u2018p\u2019 is prepended to these magic keys."),(0,r.mdx)("p",null,"The content of the serialized response is described in the ",(0,r.mdx)("a",{parentName:"p",href:"/fbthrift/docs/spec/protocol/interface/#response"},"interface spec"),"."),(0,r.mdx)("h2",{id:"interactions"},"Interactions"),(0,r.mdx)("p",null,"A method can create an interaction and then behaves like one of the four other method kinds. It returns an interaction handle, which is a typed channel that also owns the interaction. Destroying or disposing of this handle sends a signal to the server that terminates the interaction, allowing it to free resources.\nOne of the design goals of interactions is that it is possible to complete the entire lifecycle in a single round trip. The untyped interface permits sending requests on and then terminating the interaction before the response is received; this is why IDs are client-generated. Languages in which performance-sensitive applications are written will likely want to support returning the interaction handle alongside the ","[first]"," response of the method and immediately (e.g. ",(0,r.mdx)("inlineCode",{parentName:"p"},"(Awaitable\u2039InteractionHandle, ResponseStruct\u203a)")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"(InteractionHandle, Awaitable\u2039ResponseStruct\u203a)"),". respectively) in their typed channel. Otherwise, the first structure is generally considered simpler."),(0,r.mdx)("h2",{id:"ordering"},"Ordering"),(0,r.mdx)("p",null,"Multiple requests sent over one channel are not ordered with one another. Requests sent in a single interaction are ordered with one another, but responses (including stream payloads) are not ordered with those for other requests in the same interaction. The payloads of a single stream are ordered."),(0,r.mdx)("h1",{id:"server-channel"},"Server channel"),(0,r.mdx)("p",null,"Implementations ",(0,r.mdx)("strong",{parentName:"p"},"should")," similarly generate a typed server channel interface in the target language using native types and asynchrony that is called into by an untyped channel. The details here are still in active development, as the server team comes up with an architecture that minimizes the implementation burden of non-C++ servers via an in-process or IPC server proxy. The server channel interface in C++ is currently called AsyncProcessorFactory."))}d.isMDXComponent=!0}}]);