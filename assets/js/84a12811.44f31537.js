"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8281],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>p,MDXProvider:()=>u,mdx:()=>f,useMDXComponents:()=>s,withMDXComponents:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),m=function(e){return function(t){var n=s(t.components);return a.createElement(e,r({},t,{components:n}))}},s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,p=d(e,["components","mdxType","originalType","parentName"]),m=s(n),u=i,h=m["".concat(o,".").concat(u)]||m[u]||c[u]||r;return n?a.createElement(h,l(l({ref:t},p),{},{components:n})):a.createElement(h,l({ref:t},p))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},284:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(83117),i=(n(67294),n(3905));const r={state:"draft"},o="Annotations",l={unversionedId:"spec/definition/annotation",id:"spec/definition/annotation",title:"Annotations",description:"Structured Annotations",source:"@site/../doc/spec/definition/annotation.md",sourceDirName:"spec/definition",slug:"/spec/definition/annotation",permalink:"/docs/spec/definition/annotation",draft:!1,editUrl:"https://github.com/facebook/fbthrift/blob/main/thrift/website/../doc/spec/definition/annotation.md",tags:[],version:"current",frontMatter:{state:"draft"},sidebar:"sidebar",previous:{title:"Definitions",permalink:"/docs/spec/definition/"},next:{title:"Compatibility",permalink:"/docs/spec/definition/compatibility"}},d={},p=[{value:"Structured Annotations",id:"structured-annotations",level:2},{value:"Grammar",id:"grammar",level:3},{value:"Examples",id:"examples",level:3},{value:"Unstructured Annotations (Deprecated)",id:"unstructured-annotations-deprecated",level:2},{value:"Scope Annotations",id:"scope-annotations",level:2},{value:"Transitive Annotations",id:"transitive-annotations",level:2},{value:"Standard Annotations",id:"standard-annotations",level:2},{value:"C++ annotations",id:"c-annotations",level:3},{value:"cpp.type",id:"cpptype",level:4},{value:"cpp.template",id:"cpptemplate",level:4},{value:"cpp.Ref",id:"cppref",level:4},{value:"cpp.noncopyable and cpp.noncomparable",id:"cppnoncopyable-and-cppnoncomparable",level:4},{value:"cpp.declare_hash and cpp.declare_equal_to",id:"cppdeclare_hash-and-cppdeclare_equal_to",level:4},{value:"cpp.cache",id:"cppcache",level:4},{value:"cpp.coroutine",id:"cppcoroutine",level:4},{value:"priority",id:"priority",level:4},{value:"message",id:"message",level:4},{value:"no_default_comparators",id:"no_default_comparators",level:4},{value:"thread",id:"thread",level:4},{value:"cpp.indirection",id:"cppindirection",level:4},{value:"frozen and frozen2",id:"frozen-and-frozen2",level:4},{value:"cpp.methods (deprecated)",id:"cppmethods-deprecated",level:4},{value:"cpp.enum_type",id:"cppenum_type",level:4},{value:"deprecated",id:"deprecated",level:4},{value:"cpp.MinimizePadding",id:"cppminimizepadding",level:4},{value:"cpp.name",id:"cppname",level:4},{value:"cpp.mixin",id:"cppmixin",level:4},{value:"cpp.Lazy",id:"cpplazy",level:4},{value:"cpp.PackIsset",id:"cpppackisset",level:4},{value:"cpp.Adapter",id:"cppadapter",level:4},{value:"Annotations for C++ Allocator Awareness",id:"annotations-for-c-allocator-awareness",level:4},{value:"cpp.allocator",id:"cppallocator",level:4},{value:"cpp.use_allocator",id:"cppuse_allocator",level:4},{value:"cpp.allocator_via",id:"cppallocator_via",level:4},{value:"Hack annotations",id:"hack-annotations",level:3},{value:"hack.adapter",id:"hackadapter",level:4},{value:"hack.attributes",id:"hackattributes",level:4},{value:"Python annotations",id:"python-annotations",level:3},{value:"python.Adapter",id:"pythonadapter",level:4},{value:"Thrift annotations",id:"thrift-annotations",level:3},{value:"thrift.Box",id:"thriftbox",level:4},{value:"thrift.SerializeInFieldIdOrder",id:"thriftserializeinfieldidorder",level:4}],m=(s="FbInternalOnly",function(e){return console.warn("Component "+s+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.mdx)("div",e)});var s;const u={toc:p};function c(e){let{components:t,...n}=e;return(0,i.mdx)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"annotations"},"Annotations"),(0,i.mdx)("h2",{id:"structured-annotations"},"Structured Annotations"),(0,i.mdx)("p",null,"Structured annotations are structural constants attached to the named IDL entities, typically representing some metadata or altering the compiler behavior. They are specified via ",(0,i.mdx)("inlineCode",{parentName:"p"},"@Annotation{key1=value1, key2=value2, ...}")," syntax before the ",(0,i.mdx)("a",{parentName:"p",href:"/docs/spec/"},"Definitions"),". Each definition may have several annotations with no duplicates allowed. ",(0,i.mdx)("inlineCode",{parentName:"p"},"@Annotation")," can be used as a syntactic sugar for ",(0,i.mdx)("inlineCode",{parentName:"p"},"@Annotation{}"),"."),(0,i.mdx)("h3",{id:"grammar"},"Grammar"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'StructuredAnnotations ::= NonEmptyStructuredAnnotationList | ""\n\nNonEmptyStructuredAnnotationList ::=\n    NonEmptyStructuredAnnotationList StructuredAnnotation\n  | StructuredAnnotation\n\nStructuredAnnotation ::= "@" ConstStruct | "@" ConstStructType\n')),(0,i.mdx)("h3",{id:"examples"},"Examples"),(0,i.mdx)("p",null,"Here's a comprehensive list of various annotated entities."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'struct FirstAnnotation {\n  1: string name;\n  2: i64 count = 1;\n}\n\nstruct SecondAnnotation {\n  2: i64 total = 0;\n  3: SecondAnnotation recurse (cpp.ref = "True");\n  4: bool is_cool;\n}\n\n@FirstAnnotation{name="my_type"}\ntypedef string annotated_string\n\n@FirstAnnotation{name="my_struct", count=3}\n@SecondAnnotationstruct\nMyStruct {\n  @SecondAnnotation{}\n  5: annotated_string tag;\n}\n\n@FirstAnnotationexception\nMyException {\n  1: string message;\n}\n\n@SecondAnnotation{total=1, is_cool=true}\nunion MyUnion {\n  1: i64 int_value;\n  2: string string_value;\n}\n\n@SecondAnnotation{total=4, recurse=SecondAnnotation{total=5}}\nservice MyService {\n  @SecondAnnotation\n  i64 my_function(2: annotated_string param);\n}\n\n@FirstAnnotation{name="shiny"}\nenum MyEnum {\n  UNKNOWN = 0;\n  @SecondAnnotation\n  FIRST = 1;\n}\n\n@FirstAnnotation{name="my_hack_enum"}\nconst map<string, string> MyConst = {\n  "ENUMERATOR": "value",\n}\n')),(0,i.mdx)("h2",{id:"unstructured-annotations-deprecated"},"Unstructured Annotations (Deprecated)"),(0,i.mdx)("p",null,"Unstructured annotations are structured as key-value pairs where the key is a string and the value is either a string or a const structure. They may be applied to ",(0,i.mdx)("a",{parentName:"p",href:"/docs/spec/"},"definitions")," in the Thrift language, following that construct."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'Annotations ::=\n  "(" AnnotationList ["," | ";"] ")" |\n  "(" ")"\n\nAnnotationList ::=\n  AnnotationList ("," | ";") Annotation |\n  Annotation\n\nAnnotation ::=\n  Name [ "=" ( Name | StringLiteral ) ]\n')),(0,i.mdx)("p",null,"If a value is not present, then the default value of ",(0,i.mdx)("inlineCode",{parentName:"p"},'"1"')," (a string) is assumed."),(0,i.mdx)("h2",{id:"scope-annotations"},"Scope Annotations"),(0,i.mdx)("p",null,"How to specify what types of definitions an annotation can be applied to. See ",(0,i.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift/blob/v2022.07.18.00/thrift/annotation/scope.thrift#L24-L57"},"scope.thrift"),"."),(0,i.mdx)("h2",{id:"transitive-annotations"},"Transitive Annotations"),(0,i.mdx)("p",null,"Applies effects of sibling annotations. See ",(0,i.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift/blob/v2022.07.18.00/thrift/annotation/scope.thrift#L71-L94"},"scope.thrift"),"."),(0,i.mdx)("h2",{id:"standard-annotations"},"Standard Annotations"),(0,i.mdx)("p",null,"The standard Thrift annotation library is a set of structured annotations (i.e. ",(0,i.mdx)("inlineCode",{parentName:"p"},"cpp.thrift"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"meta.thrift"),", and more) that is located in ",(0,i.mdx)("inlineCode",{parentName:"p"},"thrift/annotation"),"."),(0,i.mdx)("h3",{id:"c-annotations"},"C++ annotations"),(0,i.mdx)("h4",{id:"cpptype"},"cpp.type"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: field type"),(0,i.mdx)("li",{parentName:"ul"},"Value: a complete type"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'cpp_include "<unordered_map>"\ncpp_include "folly/sorted_vector_types.h"\ncpp_include "CustomMap.h"\n\ntypedef list<i64> Type1 (cpp.type = "folly::small_vector<int64_t>")\ntypedef map<string, Foo> Type2 (cpp.type = "std::unordered_map<std::string, Foo>")\ntypedef binary (cpp.type = "std::unique_ptr<folly::IOBuf>") IOBufPtr\n\nstruct Foo {\n  1: Type1 field1\n  2: Type2 field2\n  3: map<i64, double> (cpp.type = "CustomMap") field3\n  4: IOBufPtr iobuf_ptr\n}\n')),(0,i.mdx)("p",null,"This completely replaces the underlying type of a thrift for a custom implementation. It is also possible to add ",(0,i.mdx)("inlineCode",{parentName:"p"},"cpp_include")," to bring in additional data structures and use them in conjunction with ",(0,i.mdx)("inlineCode",{parentName:"p"},"cpp.type"),". It is required that the custom type matches the specified Thrift type even for internal container types. Prefer types that can leverage",(0,i.mdx)("inlineCode",{parentName:"p"},"reserve(size_t)")," as Thrift makes uses these optimizations.",(0,i.mdx)("em",{parentName:"p"},"Special Case"),": ",(0,i.mdx)("inlineCode",{parentName:"p"},'cpp.type="std::unique_ptr<folly::IOBuf>"'),": This annotation can be used to define a type as ",(0,i.mdx)("inlineCode",{parentName:"p"},"IOBuf")," or ",(0,i.mdx)("inlineCode",{parentName:"p"},"unique_ptr<IOBuf>")," so that you can leverage Thrift2's support for zero-copy buffer manipulation through ",(0,i.mdx)("inlineCode",{parentName:"p"},"IOBuf"),".During deserialization, thrift receives a buffer that is used to allocate the appropriate fields in the struct. When using smart pointers, instead of making a copy of the data, it only modifies the pointer to point to the address that is used by the buffer."),(0,i.mdx)("p",null,"The custom type must provide the following methods"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("em",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"em"},"list")),": ",(0,i.mdx)("em",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"em"},"push_back(T)"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("em",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"em"},"map")),": ",(0,i.mdx)("em",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"em"},"insert(std::pair<T1, T2>)"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("em",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"em"},"set")),": ",(0,i.mdx)("em",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"em"},"insert(T)")))),(0,i.mdx)("h4",{id:"cpptemplate"},"cpp.template"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: container field type"),(0,i.mdx)("li",{parentName:"ul"},"Value: a template"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'cpp_include "folly/sorted_vector_types.h"\n\nstruct Example {\n  1: set<i64> (cpp.template = "folly::sorted_vector_set") shards;\n}\n')),(0,i.mdx)("p",null,"Specifies a template to use for the container type to replace the default. It somewhat overlaps with ",(0,i.mdx)("inlineCode",{parentName:"p"},"cpp.type")," but the advantage is probably you just need to specify the template type once in the annotation, without repeating the inner types."),(0,i.mdx)("h4",{id:"cppref"},"cpp.Ref"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: field name"),(0,i.mdx)("li",{parentName:"ul"},"Type:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"cpp.RefType.Unique")," : ",(0,i.mdx)("inlineCode",{parentName:"li"},"std::unique_ptr<T>")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"cpp.RefType.Shared")," : ",(0,i.mdx)("inlineCode",{parentName:"li"},"std::shared_ptr<const T> ")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"cpp.RefType.SharedMutable")," : ",(0,i.mdx)("inlineCode",{parentName:"li"},"std::shared_ptr<T>"),":"))),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"struct BinaryTree {\n  @cpp.Ref{type = cpp.RefType.Unique}\n  1: BinaryTree left;\n  @cpp.Ref\n  2: BinaryTree right;\n  @cpp.Ref{type = cpp.RefType.SharedMutable}\n  3: BinaryTree parent;\n  @cpp.Ref{type = cpp.RefType.Shared}\n  4: BinaryTree root;\n  5: i16 item;\n}\n")),(0,i.mdx)("p",null,"Makes a field a reference, not a value and Thrift generates a ",(0,i.mdx)("inlineCode",{parentName:"p"},"std::unique_ptr/std::shared_ptr")," for the annotated field, not a value. This annotation is added to support recursive types. However, you can also use it to turn a field from a value to a pointer. ",(0,i.mdx)("inlineCode",{parentName:"p"},"@cpp.Ref")," is equivalent having type",(0,i.mdx)("inlineCode",{parentName:"p"},"@cpp.RefType.Unique"),". All ",(0,i.mdx)("inlineCode",{parentName:"p"},"@cpp.Ref")," fields ",(0,i.mdx)("strong",{parentName:"p"},"should be")," optional."),(0,i.mdx)("p",null,"NOTE: A struct may transitively contain itself as a field only if at least one of the fields in the inclusion chain is either an optional Ref field or a container. Otherwise the struct would have infinite size. See ",(0,i.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift/blob/main/thrift/test/Recursive.thrift"},(0,i.mdx)("inlineCode",{parentName:"a"},"thrift/test/Recursive.thrift"))," for examples. "),(0,i.mdx)("h4",{id:"cppnoncopyable-and-cppnoncomparable"},"cpp.noncopyable and cpp.noncomparable"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: struct/union/exception"),(0,i.mdx)("li",{parentName:"ul"},"Value: None"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'typedef binary (cpp.type = "folly::IOBuf") IOBuf\n\nunion NonCopyableUnion {\n  1: i32 a,\n  2: IOBuf buf,\n} (cpp.noncopyable, cpp.noncomparable)\n')),(0,i.mdx)("p",null,"This is to avoid generating copy constructor/copy assignment constructor and overridden equality operator for types. You rarely need to use them."),(0,i.mdx)("h4",{id:"cppdeclare_hash-and-cppdeclare_equal_to"},"cpp.declare_hash and cpp.declare_equal_to"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: struct"),(0,i.mdx)("li",{parentName:"ul"},"Value: None")),(0,i.mdx)("p",null,"Adds a ",(0,i.mdx)("inlineCode",{parentName:"p"},"std::hash")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"std::equal_to")," specialization for the Thrift struct. You need to provide your own hash and equal_to implementation. Use this annotation if you want to use your Thrift struct as the key type of ",(0,i.mdx)("inlineCode",{parentName:"p"},"std::unordered_map")," or other unordered associative containers."),(0,i.mdx)("h4",{id:"cppcache"},"cpp.cache"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: method parameter, must be a string and only one of the parameters can have this annotation"),(0,i.mdx)("li",{parentName:"ul"},"Value: None")),(0,i.mdx)("p",null,"This is added by the SMC team to support their custom processor, which caches response and uses the parameter annotated by ",(0,i.mdx)("inlineCode",{parentName:"p"},"cpp.cache")," as the key."),(0,i.mdx)("h4",{id:"cppcoroutine"},"cpp.coroutine"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: method"),(0,i.mdx)("li",{parentName:"ul"},"Value: None"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"service MyService {\n  void m1() (cpp.coroutine);\n}\n")),(0,i.mdx)("p",null,"Enable coroutine generation. See [","[Thrift/ImplementingAServer/]","] for more information."),(0,i.mdx)("h4",{id:"priority"},"priority"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: method"),(0,i.mdx)("li",{parentName:"ul"},"Value: None"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"service MyService {\n  void m1() (priority = HIGH);\n  void m2();\n}\n")),(0,i.mdx)("p",null,"Designate a priority level for the annotated method. By default all methods have the same priority level. This is only used in C++ when ",(0,i.mdx)("inlineCode",{parentName:"p"},"ThriftServer")," uses a ",(0,i.mdx)("inlineCode",{parentName:"p"},"PriorityThreadManager"),"."),(0,i.mdx)("h4",{id:"message"},"message"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: exception"),(0,i.mdx)("li",{parentName:"ul"},"Value: name of a string field"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'exception MyException {\n  1: string errorMessage\n} (message = "errorMessage")\n')),(0,i.mdx)("p",null,"The annotation's value should be the name of a string field in the exception. The code generator then generates a constructor which uses a string to initialize that string field. The exception class's ",(0,i.mdx)("inlineCode",{parentName:"p"},"what()")," method is overridden to returns the content of that string field."),(0,i.mdx)("h4",{id:"no_default_comparators"},"no_default_comparators"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: struct"),(0,i.mdx)("li",{parentName:"ul"},"Value: none")),(0,i.mdx)("p",null,"Do not generate a default comparator even if the struct is orderable."),(0,i.mdx)("h4",{id:"thread"},"thread"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: method"),(0,i.mdx)("li",{parentName:"ul"},"Value: eb or tm (default)"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"service MyService {\n  int m1() (thread = 'eb');\n  int m2();\n}\n")),(0,i.mdx)("p",null,"Causes the request to be executed on the event base thread directly instead of rescheduling onto a thread manager thread, provided the async",(0,i.mdx)("em",{parentName:"p"},"eb")," handler method is implemented. You should only execute the request on the event base thread if it is very fast and you have measured that rescheduling is a substantial chunk of your service's CPU usage. If a request executing on the event base thread blocks or takes a long time, all other requests sharing the same event base are affected and latency will increase significantly. This is only supported in C++. We strongly discourage the use of this annotation unless strictly necessary. You will have to implement the harder-to-use async",(0,i.mdx)("em",{parentName:"p"},"eb")," handler method; implementing any other method will cause the rescheduling regardless of this annotation. This also disables queue timeouts, an important form of overload protection."),(0,i.mdx)("h4",{id:"cppindirection"},"cpp.indirection"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: field type"),(0,i.mdx)("li",{parentName:"ul"},"Value: a method to call from the base type"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'# Thrift file\ntypedef i64 (cpp.type = "Seconds", cpp.indirection) seconds\nstruct MyStruct {\n  1: seconds s;\n}\n\n// C++ file\nstruct Seconds : private boost::totally_ordered<Seconds> {\n  FBTHRIFT_CPP_DEFINE_MEMBER_INDIRECTION_FN(number);\n  std::int64_t number = 0;\n  Seconds() = default;\n  Seconds(std::int64_t number_) : number(number_) {}\n  bool operator==(Seconds that) const { return number == that.number; }\n  bool operator<(Seconds that) const { return number < that.number; }\n};\n')),(0,i.mdx)("p",null,"Together with ",(0,i.mdx)("inlineCode",{parentName:"p"},"cpp.type")," annotation, this annotation defines a new type and uses the indirect method to access its value."),(0,i.mdx)("h4",{id:"frozen-and-frozen2"},"frozen and frozen2"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: struct, not exception. This is also supported through code generator flag and currently only used through code generator flag.")),(0,i.mdx)("h4",{id:"cppmethods-deprecated"},"cpp.methods (deprecated)"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: struct"),(0,i.mdx)("li",{parentName:"ul"},"Value: valid code"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'struct MyStruct {\n    1: i32 anInteger;\n  } (\n    cpp.methods = "\n      public:\n        std::string toString() const;\n    "\n  )\n')),(0,i.mdx)("p",null,"Insert some code into the Thrift generated header file."),(0,i.mdx)("h4",{id:"cppenum_type"},"cpp.enum_type"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: enum"),(0,i.mdx)("li",{parentName:"ul"},"Value: an integer type for c++ to use as the underlying type of enum"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'enum TermIdType {\n GENERIC_FP96 = 0,\n PREFIX_USERID = 1,\n} (cpp.enum_type = "int")\n')),(0,i.mdx)("h4",{id:"deprecated"},"deprecated"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: struct/member"),(0,i.mdx)("li",{parentName:"ul"},"Value: None or a custom message.")),(0,i.mdx)("p",null,"This will mark the struct or member as deprecated and will issue a warning when compiling.Note that if other Thrift files include a Thrift file with deprecated annotations, those files will be treated as using these fields and propagate warnings when included. If ",(0,i.mdx)("inlineCode",{parentName:"p"},"a.thrift")," marks struct ",(0,i.mdx)("inlineCode",{parentName:"p"},"foo")," as deprecated, ",(0,i.mdx)("inlineCode",{parentName:"p"},"b.thrift")," includes ",(0,i.mdx)("inlineCode",{parentName:"p"},"a.thrift"),", and ",(0,i.mdx)("inlineCode",{parentName:"p"},"c.cpp")," includes ",(0,i.mdx)("inlineCode",{parentName:"p"},"b.thrift"),", deprecated warnings concerning foo will be raised when building ",(0,i.mdx)("inlineCode",{parentName:"p"},"c.cpp")," even if the file doesn't actually use ",(0,i.mdx)("inlineCode",{parentName:"p"},"foo"),"."),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'// Default struct message: "class MyStruct is deprecated"\nstruct MyStruct {\n 1: i32 a\n} (deprecated)\n\nstruct MyStruct3 {\n 1: i32 a = 0 (deprecated)  // Default member message: "i32 a is deprecated"\n} (deprecated = "This is not longer supported")\n')),(0,i.mdx)("h4",{id:"cppminimizepadding"},"cpp.MinimizePadding"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: struct"),(0,i.mdx)("li",{parentName:"ul"},"Value: none"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'include "thrift/annotation/cpp.thrift"\n\n@cpp.MinimizePadding\nstruct Padded {\n  1: required byte small\n  2: required i64 big\n  3: required i16 medium\n  4: required i32 biggish\n  5: required byte tiny\n}\n')),(0,i.mdx)("p",null,"This annotation enables reordering of fields in the generated C++ struct to minimize padding. This is achieved by placing the fields in the order of decreasing alignments. The order of fields with the same alignment is preserved.For example, the C++ fields for the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Padded")," Thrift struct above will be generated in the following order:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"int64_t big;\nint32_t biggish;\nint16_t medium;\nint8_t small;\nint8_t tiny;\n")),(0,i.mdx)("p",null,"which gives the size of 16 bytes compared to 32 bytes if ",(0,i.mdx)("inlineCode",{parentName:"p"},"cpp.MinimizePadding")," was not specified."),(0,i.mdx)("h4",{id:"cppname"},"cpp.name"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: member"),(0,i.mdx)("li",{parentName:"ul"},"Value: string with a valid C++ identifier"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'struct Error {\n  1: string message\n  2: i32 errno (cpp.name = "error_code")\n}\n')),(0,i.mdx)("p",null,"This annotation renames all C++ entities (member variables, parameter names, etc.) generated from the Thrift field. For example, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"errno")," field in the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Error")," struct will be renamed to ",(0,i.mdx)("inlineCode",{parentName:"p"},"error_code"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"class Error {\n public:\n  Error() : error_code(0) {}\n\n  std::string message;\n  int32_t error_code;\n};\n")),(0,i.mdx)("p",null,"In most cases a much better solution is to rename the problematic Thrift field itself. Only use the ",(0,i.mdx)("inlineCode",{parentName:"p"},"cpp.name")," annotation if such renaming is problematic, e.g. when the field name appears in code as a string, particularly when using JSON serialization, and it is hard to change all usage sites."),(0,i.mdx)("h4",{id:"cppmixin"},"cpp.mixin"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: member"),(0,i.mdx)("li",{parentName:"ul"},"Value: none"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"struct Mixin1 { 1: i32 field1 }\nstruct Mixin2 { 1: i32 field2 }\nstruct Foo {\n  1: Mixin1 m1 (cpp.mixin);\n  2: Mixin2 m2 (cpp.mixin);\n  3: i32 field3;\n}\n")),(0,i.mdx)("p",null,"Then in C++ we could access fields in Mixin from Foo"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"Foo f;\nf.field1_ref();  // Access field1 in Mixin1\n")),(0,i.mdx)("p",null,"Read more: Thrift/Mixins"),(0,i.mdx)("h4",{id:"cpplazy"},"cpp.Lazy"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: field"),(0,i.mdx)("li",{parentName:"ul"},"Value: ",(0,i.mdx)("inlineCode",{parentName:"li"},"true")),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"struct Foo {\n  1: list<i32> small_field;\n  2: list<i32> large_field (cpp.experimental.lazy);\n}\n")),(0,i.mdx)("p",null,"Lazily deserialize large field on first access."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"Foo foo;\napache::thrift::CompactSerializer::deserialize(serializedData, foo);\n\n// large_field is lazy field, it will be deserialized on first access\n// The data will be deserialized in method call large_field_ref()\nLOG(INFO) << foo.large_field_ref()->size();\n\n// Result will be cached, we won't deserialize again\nLOG(INFO) << foo.large_field_ref()->size();\n")),(0,i.mdx)("p",null,"Read more: Thrift/Lazy/"),(0,i.mdx)("h4",{id:"cpppackisset"},"cpp.PackIsset"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: field"),(0,i.mdx)("li",{parentName:"ul"},"Value: ",(0,i.mdx)("inlineCode",{parentName:"li"},"none")),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'include "thrift/annotation/cpp.thrift"\n@cpp.PackIsset\nstruct Foo {\n  1: optional i32 field1\n  2: i32 field2\n}\n')),(0,i.mdx)("p",null,"Read more: Thrift/Isset_Bitpacking/"),(0,i.mdx)("h4",{id:"cppadapter"},"cpp.Adapter"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: field, typedef"),(0,i.mdx)("li",{parentName:"ul"},"Value: name of adapter"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'// in C++ Header\nstruct BitsetAdapter {\n  static std::bitset<32> fromThrift(std::uint32_t t) { return {t}; }\n  static std::uint32_t toThrift(std::bitset<32> t) { return t.to_ullong(); }\n};\n\n// In thrift file\nstruct Foo {\n  @cpp.Adapter{name = "BitsetAdapter"}\n  1: i32 flags;\n}\n\n// in C++ file\nFoo foo;\nfoo.flags()->set(0); // set 0th bit\n')),(0,i.mdx)("p",null,"More detail: Thrift/Thrift_Guide/Adapter/"),(0,i.mdx)("h4",{id:"annotations-for-c-allocator-awareness"},"Annotations for C++ Allocator Awareness"),(0,i.mdx)("p",null,"Example C++:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"using MyAlloc = std::scoped_allocator_adaptor<folly::SysArenaAllocator<char>>;\ntemplate <class T> using MyVector = std::vector<T, MyAlloc>;\ntemplate <class K, class V> using MyMap = std::map<K, V, std::less<K>, MyAlloc>;\n")),(0,i.mdx)("p",null,"Thrift IDL usage example (assuming ",(0,i.mdx)("inlineCode",{parentName:"p"},"cpp_include")," the above):"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'struct aa_struct {\n  1: list<i32> (cpp.use_allocator, cpp.template = "MyVector") aa_list;\n  2: map<i32, i32> (cpp.use_allocator, cpp.template = "MyMap") aa_map;\n  3: set<i32> not_aa_set;\n} (cpp.allocator = "MyAlloc", cpp.allocator_via = "aa_list")\n')),(0,i.mdx)("h4",{id:"cppallocator"},"cpp.allocator"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: struct"),(0,i.mdx)("li",{parentName:"ul"},"Value: string name of a type conforming to the ",(0,i.mdx)("a",{parentName:"li",href:"https://en.cppreference.com/w/cpp/named_req/Allocator"},'C++ named requirement "Allocator"'))),(0,i.mdx)("p",null,"Declares that this is an allocator-aware structure, using the specified C++ allocator type. When this annotation is present, the Thrift compiler will generate additional code sufficient to meet the ",(0,i.mdx)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/named_req/AllocatorAwareContainer"},'C++ named requirement "AllocatorAwareContainer":')),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"allocator_type")," typedef"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"get_allocator()")," function"),(0,i.mdx)("li",{parentName:"ul"},'Three "allocator-extended" constructors')),(0,i.mdx)("h4",{id:"cppuse_allocator"},"cpp.use_allocator"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: member"),(0,i.mdx)("li",{parentName:"ul"},"Value: none")),(0,i.mdx)("p",null,"Indicates that the structure's allocator should be passed down to this member at construction time."),(0,i.mdx)("h4",{id:"cppallocator_via"},"cpp.allocator_via"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: struct"),(0,i.mdx)("li",{parentName:"ul"},"Value: string with a valid C++ identifier which is a member field in this struct")),(0,i.mdx)("p",null,"This is a structure size optimization. The naive implementation of ",(0,i.mdx)("inlineCode",{parentName:"p"},"get_allocator()")," requires an additional data member to \u201cremember\u201d the allocator. With ",(0,i.mdx)("inlineCode",{parentName:"p"},"cpp.allocator_via"),", we instead delegate this responsibility to one of the allocator-aware fields."),(0,i.mdx)("h3",{id:"hack-annotations"},"Hack annotations"),(0,i.mdx)("h4",{id:"hackadapter"},"hack.adapter"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: field type"),(0,i.mdx)("li",{parentName:"ul"},"Value: a class that implements the ",(0,i.mdx)("inlineCode",{parentName:"li"},"IThriftAdapter")," interface"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"// in thrift:\nstruct Document {\n  1: i32 (hack.adapter = '\\TimestampToTimeAdapter') created_time;\n}\n// thrift compiler will generate this for you:\nclass Document implements \\IThriftStruct {\n...\n  public Time $created_time;\n...\n}\n// in hack:\nfinal class TimestampToTimeAdapter implements IThriftAdapter {\n  const type TThriftType = int;\n  const type THackType = Time;\n  public static function fromThrift(int $seconds)[]: Time {\n    return Time::fromEpochSeconds($seconds);\n  }\n  public static function toThrift(Time $time): int {\n    return $hack_value->asFullSecondsSinceEpoch();\n  }\n}\n// elsewhere in hack:\nfunction timeSinceCreated(Document $doc): Duration {\n  // $doc->created_time is of type Time\n  return Duration::between(Time::now(), $doc->created_time);\n}\n")),(0,i.mdx)("p",null,"This completely replaces the underlying type of a thrift for a custom implementation and uses the specified adapter to convert to and from the underlying Thrift type during (de)serialization."),(0,i.mdx)("h4",{id:"hackattributes"},"hack.attributes"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: field or struct type"),(0,i.mdx)("li",{parentName:"ul"},"Value: add attributes like ",(0,i.mdx)("inlineCode",{parentName:"li"},"JSEnum")," to structs or fields"),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"// In thrift\nenum MyEnum {\n  ALLOWED = 1,\n  THIS_IS_ALLOWED  =  2,\n  THIS_IS_ALLOWED_2 = 3,\n}(\n  hack.attributes=\n    \"\\JSEnum(shape('name' => 'MyEnum')),\n    \\GraphQLEnum('MyEnum', 'Description for my enum',)\"\n)\nstruct MyThriftStruct {\n  1: string foo (hack.attributes = \"FieldAttribute\");\n  2: string bar;\n  3: string baz;\n} (hack.attributes = \"ClassAttribute\")\n")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"//thrift compiler will generate this for you\n<<\\JSEnum(shape('name' => 'MyEnum')),\n\\GraphQLEnum('MyEnum', 'Description for my enum',)>>\nenum MyEnum: int {\n ALLOWED = 1;\n THIS_IS_ALLOWED = 2;\n THIS_IS_ALLOWED_2 = 3;\n}\n<<ClassAttribute>>\nclass MyThriftStruct implements \\IThriftStruct {\n ....\n\n <<FieldAttribute>>\n public string $foo;\n\n ....\n}\n")),(0,i.mdx)("h3",{id:"python-annotations"},"Python annotations"),(0,i.mdx)("h4",{id:"pythonadapter"},"python.Adapter"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: field, typedef"),(0,i.mdx)("li",{parentName:"ul"},"Value: a class that implements the ",(0,i.mdx)("a",{parentName:"li",href:"https://github.com/facebook/fbthrift/blob/main/thrift/lib/python/adapter.pyi"},"Adapter")),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'// In Python file\nclass DatetimeAdapter(Adapter[int, datetime]):\n    @classmethod\n    def from_thrift(cls, original: int) -> datetime:\n        return datetime.fromtimestamp(original)\n\n    @classmethod\n    def to_thrift(cls, adapted: datetime) -> int:\n        return int(adapted.timestamp())\n\n// In thrift file\nstruct Foo {\n  @python.Adapter{\n    name = "DatetimeAdapter",\n    typeHint = "datetime.datetime",\n  }\n  1: i32 dt;\n}\n\n// In python file\nfoo = Foo()\nassert isinstance(foo.dt, datetime)\nassert foo.dt.timestamp() == 0\n')),(0,i.mdx)("p",null,"This completely replaces the underlying type of a thrift for a custom implementation and uses the specified adapter to convert to and from the underlying Thrift type during (de)serialization."),(0,i.mdx)(m,{mdxType:"FbInternalOnly"},(0,i.mdx)("p",null,"More detail: ",(0,i.mdx)("a",{parentName:"p",href:"https://www.internalfb.com/intern/wiki/Thrift/Thrift_Guide/Adapter/"},"https://www.internalfb.com/intern/wiki/Thrift/Thrift_Guide/Adapter/"))),(0,i.mdx)("h3",{id:"thrift-annotations"},"Thrift annotations"),(0,i.mdx)("p",null,"Thrift annotations work in all officially supported languages."),(0,i.mdx)("h4",{id:"thriftbox"},"thrift.Box"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Where to use: optional field name"),(0,i.mdx)("li",{parentName:"ul"},"Value: ",(0,i.mdx)("inlineCode",{parentName:"li"},"true")),(0,i.mdx)("li",{parentName:"ul"},"Example:")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"struct RecList {\n  @thrift.Box\n  1: optional RecList next;\n}\n")),(0,i.mdx)("p",null,"This indicates that a subobject should be allocated separately (e.g. because it is large and infrequently set)."),(0,i.mdx)("p",null,"NOTE: The APIs and initialization behavior are same as normal field, but different from ",(0,i.mdx)("inlineCode",{parentName:"p"},"@cpp.Ref"),". e.g."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"struct Foo {\n  1: optional i32 normal;\n  @thrift.Box\n  2: optional i32 boxed;\n  @cpp.Ref\n  3: optional i32 referred;\n}\n")),(0,i.mdx)("p",null,"in C++"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"Foo foo;\nEXPECT_FALSE(foo.normal().has_value()); // okay\nEXPECT_FALSE(foo.boxed().has_value()); // okay\nEXPECT_FALSE(foo.referred().has_value()); // build failure: std::unique_ptr doesn't have has_value method\n\nEXPECT_EQ(*foo.normal(), 0); // throw bad_field_access exception\nEXPECT_EQ(*foo.boxed(), 0); // throw bad_field_access exception\nEXPECT_EQ(*foo.referred(), 0); // okay, field has value by default\n")),(0,i.mdx)("h4",{id:"thriftserializeinfieldidorder"},"thrift.SerializeInFieldIdOrder"),(0,i.mdx)("p",null,"Serialize fields in field id ascending order instead of fields declaration order. This makes serialization result deterministic after swapping fields. In addition, it can reduce payload size only for compact protocol. Example"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"@thrift.SerializeInFieldIdOrder\nstruct Foo {\n  2: byte a;\n  1: byte b;\n}\n")),(0,i.mdx)("p",null,"This reduces serialized data size from 5 bytes to 4 bytes for compact protocol."),(0,i.mdx)("p",null,"Why? Compact protocol stored delta of field id, instead of actual field id in payload. When field is serialized out of field id order, delta=0 will be written, followed with actual field id, thus when field is serialized out of field id order, it uses more bytes for field id."),(0,i.mdx)("p",null,"NOTE: This annotation won't reduce payload size for other protocols."))}c.isMDXComponent=!0}}]);