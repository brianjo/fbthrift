"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5307],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>l,MDXProvider:()=>f,mdx:()=>h,useMDXComponents:()=>m,withMDXComponents:()=>p});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(){return i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},i.apply(this,arguments)}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function d(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),p=function(e){return function(n){var t=m(n.components);return r.createElement(e,i({},n,{components:t}))}},m=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):d(d({},n),e)),t},f=function(e){var n=m(e.components);return r.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=m(t),f=a,u=p["".concat(o,".").concat(f)]||p[f]||c[f]||i;return t?r.createElement(u,d(d({ref:n},l),{},{components:t})):r.createElement(u,d({ref:n},l))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=u;var d={};for(var s in n)hasOwnProperty.call(n,s)&&(d[s]=n[s]);d.originalType=e,d.mdxType="string"==typeof e?e:a,o[1]=d;for(var l=2;l<i;l++)o[l]=t[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},13580:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>d,toc:()=>l});var r=t(83117),a=(t(67294),t(3905));const i={},o="Header format for the THeader.h",d={unversionedId:"internals/header-format",id:"internals/header-format",title:"Header format for the THeader.h",description:"0 1 2 3 4 5 6 7 8 9 a b c d e f 0 1 2 3 4 5 6 7 8 9 a b c d e f",source:"@site/../doc/internals/header-format.md",sourceDirName:"internals",slug:"/internals/header-format",permalink:"/docs/internals/header-format",draft:!1,editUrl:"https://github.com/facebook/fbthrift/blob/main/thrift/website/../doc/internals/header-format.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Function signatures",permalink:"/docs/internals/function-signatures"},next:{title:"mstch-based code generators",permalink:"/docs/internals/mstch"}},s={},l=[{value:"PADDING:",id:"padding",level:3},{value:"Transform IDs:",id:"transform-ids",level:3},{value:"Info IDs:",id:"info-ids",level:3}],p={toc:l};function m(e){let{components:n,...t}=e;return(0,a.mdx)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("h1",{id:"header-format-for-the-theaderh"},"Header format for the THeader.h"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"  0 1 2 3 4 5 6 7 8 9 a b c d e f 0 1 2 3 4 5 6 7 8 9 a b c d e f\n+----------------------------------------------------------------+\n| 0|                         LENGTH32                            |\n+----------------------------------------------------------------+\n|                           LENGTH_MSW*                          |\n+----------------------------------------------------------------+\n|                           LENGTH_LSW*                          |\n+----------------------------------------------------------------+\n| 0|       HEADER MAGIC          |            FLAGS              |\n+----------------------------------------------------------------+\n|                         SEQUENCE NUMBER                        |\n+----------------------------------------------------------------+\n| 0|     Header Size(/32)        | ...\n+---------------------------------\n\n                  Header is of variable size:\n                   (and starts at offset 14)\n\n+----------------------------------------------------------------+\n|         PROTOCOL ID  (varint)  |   NUM TRANSFORMS (varint)     |\n+----------------------------------------------------------------+\n|      TRANSFORM 0 ID (varint)   |        TRANSFORM 0 DATA ...\n+----------------------------------------------------------------+\n|         ...                              ...                   |\n+----------------------------------------------------------------+\n|        INFO 0 ID (varint)      |       INFO 0  DATA ...\n+----------------------------------------------------------------+\n|         ...                              ...                   |\n+----------------------------------------------------------------+\n|                                                                |\n|                              PAYLOAD                           |\n|                                                                |\n+----------------------------------------------------------------+\n")),(0,a.mdx)("p",null,"The ",(0,a.mdx)("inlineCode",{parentName:"p"},"LENGTH32")," field is 32 bits, and counts the remaining bytes in the\npacket, NOT including the length field.  For packets 1GiB or larger, the\nlength field contains the magic value ",(0,a.mdx)("inlineCode",{parentName:"p"},"BIG_FRAME_MAGIC"),", and the fields\n",(0,a.mdx)("inlineCode",{parentName:"p"},"LENGTH_MSW")," and ",(0,a.mdx)("inlineCode",{parentName:"p"},"LENGTH_LSW")," follow and contain the 64-bit length (not\nincluding the ",(0,a.mdx)("inlineCode",{parentName:"p"},"LENGTH32"),", ",(0,a.mdx)("inlineCode",{parentName:"p"},"LENGTH_MSW"),", and ",(0,a.mdx)("inlineCode",{parentName:"p"},"LENGTH_LSW")," fields).  For packets\nsmaller than 1GiB, the ",(0,a.mdx)("inlineCode",{parentName:"p"},"LENGTH_MSW")," and ",(0,a.mdx)("inlineCode",{parentName:"p"},"LENGTH_LSW")," fields do not appear, and\nthe ",(0,a.mdx)("inlineCode",{parentName:"p"},"LENGTH32")," field contains the actual length of the packet.  The header size\nfield is 16 bits, and defines the size of the header remaining NOT including\nthe ",(0,a.mdx)("inlineCode",{parentName:"p"},"HEADER MAGIC"),", ",(0,a.mdx)("inlineCode",{parentName:"p"},"FLAGS"),", ",(0,a.mdx)("inlineCode",{parentName:"p"},"SEQUENCE NUMBER")," and header size fields.  The\nHeader size field is in bytes/4."),(0,a.mdx)("p",null,"Note that the ",(0,a.mdx)("inlineCode",{parentName:"p"},"LENGTH_MSW")," and ",(0,a.mdx)("inlineCode",{parentName:"p"},"LENGTH_LSW")," fields only appear if the\n",(0,a.mdx)("inlineCode",{parentName:"p"},"LENGTH32")," field contains the magic value ",(0,a.mdx)("inlineCode",{parentName:"p"},"BIG_FRAME_MAGIC"),' (0x42494746, "BIGF"\nbig-endian).'),(0,a.mdx)("p",null,"The transform IDs are varints.  The data for each transform is\ndefined by the transform ID in the code - no size is given in the\nheader.  If a transform ID is specified from a client and the server\ndoesn't know about the transform ID, an error MUST be returned as we\ndon't know how to transform the data."),(0,a.mdx)("p",null,"Conversely, data in the info headers is ignorable.  This should only\nbe things like timestamps, debugging tracing, etc.  Using the header\nsize you should be able to skip this data and read the payload safely\nif you don't know the info ID."),(0,a.mdx)("p",null,"Info's should be oldest supported to newest supported order, so that\nif we read an info ID we don't support, none of the remaining info\nID's will be supported either, and we can safely skip to the payload."),(0,a.mdx)("p",null,"Info ID's and transform ID's should share the same ID space."),(0,a.mdx)("h3",{id:"padding"},"PADDING:"),(0,a.mdx)("p",null,"Header will be padded out to next 4-byte boundary with ",(0,a.mdx)("inlineCode",{parentName:"p"},"0x00"),"."),(0,a.mdx)("h3",{id:"transform-ids"},"Transform IDs:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"ZLIB_TRANSFORM 0x01 - No data for this.  Use zlib to (de)compress the\n                      data.\n\nHMAC_TRANSFORM 0x02 - Deprecated and no longer supported.\nSNAPPY_TRANSFORM  0x03  - Deprecated and no longer supported.\n")),(0,a.mdx)("h3",{id:"info-ids"},"Info IDs:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"INFO_KEYVALUE 0x01 - varint32 number of headers.\n                   - key/value pairs of varstrings (varint16 length plus\n                     no-trailing-null string).\n")))}m.isMDXComponent=!0}}]);