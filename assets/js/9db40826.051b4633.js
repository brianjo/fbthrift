"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9218],{3905:(e,t,a)=>{a.r(t),a.d(t,{MDXContext:()=>d,MDXProvider:()=>p,mdx:()=>h,useMDXComponents:()=>u,withMDXComponents:()=>c});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(){return o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(e[r]=a[r])}return e},o.apply(this,arguments)}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var d=r.createContext({}),c=function(e){return function(t){var a=u(t.components);return r.createElement(e,o({},t,{components:a}))}},u=function(e){var t=r.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=u(e.components);return r.createElement(d.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,i=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=u(a),p=n,f=c["".concat(i,".").concat(p)]||c[p]||m[p]||o;return a?r.createElement(f,s(s({ref:t},d),{},{components:a})):r.createElement(f,s({ref:t},d))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var d=2;d<o;d++)i[d]=a[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}f.displayName="MDXCreateElement"},19803:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var r=a(83117),n=(a(67294),a(3905));const o={},i="Dynamic Values (Any)",s={unversionedId:"beta/any",id:"beta/any",title:"Dynamic Values (Any)",description:"Any",source:"@site/../doc/beta/any.md",sourceDirName:"beta",slug:"/beta/any",permalink:"/fbthrift/docs/beta/any",draft:!1,editUrl:"https://github.com/facebook/fbthrift/blob/main/thrift/website/../doc/beta/any.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Adapters",permalink:"/fbthrift/docs/beta/adapter"},next:{title:"C++",permalink:"/fbthrift/docs/cpp/"}},l={},d=[{value:"Any",id:"any",level:2},{value:"Paths",id:"paths",level:2},{value:"FieldMask",id:"fieldmask",level:2},{value:"Overview",id:"overview",level:3},{value:"Motivation",id:"motivation",level:3},{value:"Data Structure",id:"data-structure",level:3},{value:"APIs",id:"apis",level:3},{value:"MaskBuilder",id:"maskbuilder",level:3},{value:"Logical operators",id:"logical-operators",level:3},{value:"Compare",id:"compare",level:3},{value:"Serialization with Mask",id:"serialization-with-mask",level:3},{value:"Protocol Object and Value",id:"protocol-object-and-value",level:2}],c={toc:d};function u(e){let{components:t,...a}=e;return(0,n.mdx)("wrapper",(0,r.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.mdx)("h1",{id:"dynamic-values-any"},"Dynamic Values (Any)"),(0,n.mdx)("h2",{id:"any"},"Any"),(0,n.mdx)("p",null,"How to store any value."),(0,n.mdx)("h2",{id:"paths"},"Paths"),(0,n.mdx)("p",null,"How to access values from any Thrift value."),(0,n.mdx)("h2",{id:"fieldmask"},"FieldMask"),(0,n.mdx)("h3",{id:"overview"},"Overview"),(0,n.mdx)("p",null,"Field Mask is a data structure that represents a subset of fields and nested fields of a thrift struct, with utilities to manipulate these fields (e.g., copy certain fields from one thrift object to another)."),(0,n.mdx)("h3",{id:"motivation"},"Motivation"),(0,n.mdx)("p",null,"When a client doesn't need all fields, the server can only return selected fields to the client to reduce network bandwidth."),(0,n.mdx)("h3",{id:"data-structure"},"Data Structure"),(0,n.mdx)("p",null,"Field Mask can be either an inclusive mask or an exclusive mask \u2014 fields or nested field masks that are included or excluded. The nested masks are used for masking the nested fields. (Actual definition can be found here: ",(0,n.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift/blob/main/thrift/lib/thrift/field_mask.thrift"},(0,n.mdx)("inlineCode",{parentName:"a"},"thrift/lib/thrift/field_mask.thrift")),"."),(0,n.mdx)("pre",null,(0,n.mdx)("code",{parentName:"pre"},'union Mask {\n  1: map<i16, Mask> excludes; // Fields that will be excluded\n  2: map<i16, Mask> includes; // Fields that will be included\n}\n\nconst Mask allMask = {"excludes": {}}; // Masks all fields/whole field.\nconst Mask noneMask = {"includes": {}}; // Masks no fields.`\n')),(0,n.mdx)("p",null,(0,n.mdx)("a",{parentName:"p",href:"../spec/protocol/data/#debug-protocol"},"Debug protocol")," can be used to convert Mask to a human readable string."),(0,n.mdx)("h3",{id:"apis"},"APIs"),(0,n.mdx)("p",null,"Currently it provides the following APIs (APIs are in ",(0,n.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift/blob/main/thrift/lib/cpp2/protocol/FieldMask.h"},(0,n.mdx)("inlineCode",{parentName:"a"},"thrift/lib/cpp2/protocol/FieldMask.h")),"). These APIs are available for both schemaful (ThriftStruct) and schemaless (protocol::Object) Thrift structs.\n",(0,n.mdx)("a",{parentName:"p",href:"../spec/definition/program/#packages"},"Package")," name must be defined in thrift file to use field mask APIs. It will give a compile-error without a package name."),(0,n.mdx)("pre",null,(0,n.mdx)("code",{parentName:"pre"},"// Whether field mask is compatible with thrift struct (the masked fields exist\n// in ThriftStruct)\nbool is_compatible_with<ThriftStruct>(Mask);\n\n// Call field_ref().ensure() for all masked fields and their precedents\nvoid ensure(Mask, ThriftStruct);\n\n// Remove all masked fields\nvoid clear(Mask, ThriftStruct);\n\n// Copy masked fields from src to dst. If some masked fields are not set in src,\n// remove them in dst as well.\nvoid copy(Mask, ThriftStruct src, ThriftStruct dst);\n\n// It also provides support for protocol::Object\nvoid clear(Mask, protocol::Object);\nvoid copy(Mask, protocol::Object src, protocol::Object dst);\n")),(0,n.mdx)("h3",{id:"maskbuilder"},"MaskBuilder"),(0,n.mdx)("p",null,"MaskBuilder is a wrapper for Mask that works as a strongly typed mask. It is tied to a specific thrift struct type, and it provides APIs to add fields to the Mask with field names and field identifiers like idents."),(0,n.mdx)("pre",null,(0,n.mdx)("code",{parentName:"pre"},"struct MaskBuilder<Struct> {\n    // All methods for constructing Mask return itself to chain \n    MaskBuilder& reset_to_none();\n    MaskBuilder& reset_to_all();\n    MaskBuilder& invert();\n    Mask& toThrift();\n    \n    // includes and excludes with field names and all ids\n    MaskBuilder& includes(list<string> fieldNames, const Mask& mask = allMask());\n    MaskBuilder& excludes(list<string> fieldNames, const Mask& mask = allMask());\n    // Id can be Ordinal, FieldId, Ident, TypeTag, FieldTag\n    MaskBuilder& includes<Id...>(const Mask& mask = allMask());\n    MaskBuilder& excludes<Id...>(const Mask& mask = allMask());\n    \n    // reset_and_includes calls reset_to_none() and includes()\n    // reset_and_excludes calls reset_to_all() and excludes()\n    \n    // Mask APIs\n    void ensure(Struct& obj) const;\n    void clear(Struct& obj) const;\n    void copy(const Struct& src, Struct& dst) const;\n}\n")),(0,n.mdx)("p",null,"It also provides ",(0,n.mdx)("inlineCode",{parentName:"p"},"MaskAdapter"),", which adapts ",(0,n.mdx)("inlineCode",{parentName:"p"},"Mask")," to be ",(0,n.mdx)("inlineCode",{parentName:"p"},"MaskBuilder")," in a thrift struct."),(0,n.mdx)("h3",{id:"logical-operators"},"Logical operators"),(0,n.mdx)("p",null,"These are logical operators to construct a new mask."),(0,n.mdx)("pre",null,(0,n.mdx)("code",{parentName:"pre"},"Mask operator&(const Mask&, const Mask&); // intersect\nMask operator|(const Mask&, const Mask&); // union\nMask operator-(const Mask&, const Mask&); // subtract\n")),(0,n.mdx)("h3",{id:"compare"},"Compare"),(0,n.mdx)("p",null,"Constructs a FieldMask object that includes the fields that are different in the given two Thrift structs."),(0,n.mdx)("pre",null,(0,n.mdx)("code",{parentName:"pre"},"Mask compare(const Struct& original, const Struct& modified);\n")),(0,n.mdx)("h3",{id:"serialization-with-mask"},"Serialization with Mask"),(0,n.mdx)("p",null,"Mask can be used with parseObject to construct a partial protocol::Object with only the masked fields. This also returns MaskedProtocolData, which stores the serialized data of the other fields, and serializeObject with MaskedProtocolData reserializes the object."),(0,n.mdx)("pre",null,(0,n.mdx)("code",{parentName:"pre"},"struct MaskedDecodeResult {\n  Object included;\n  MaskedProtocolData excluded;\n};\n\n// Only parses values that are masked. Unmasked fields are stored in MaskedProtocolData.\nMaskedDecodeResult parseObject<Protocol>(const folly::IOBuf& buf, Mask mask);\n\n// serialize the fields from the Object and MaskedProtocolData\nstd::unique_ptr<folly::IOBuf>\nserializeObject<Protocol>(const protocol::Object& obj, MaskedProtocolData& protocolData);\n")),(0,n.mdx)("p",null,"This is useful when updating a small part of the object from serialized data, as it doesn\u2019t need to deserialize the entire object. The function applyPatchToSerializedData performs this by extracting a mask from patch with only the updated fields."),(0,n.mdx)("pre",null,(0,n.mdx)("code",{parentName:"pre"},"std::unique_ptr<folly::IOBuf> applyPatchToSerializedData<Protocol>(\n    const protocol::Object& patch, const folly::IOBuf& buf);\n")),(0,n.mdx)("h2",{id:"protocol-object-and-value"},"Protocol Object and Value"),(0,n.mdx)("p",null,"How to manipulate any value."))}u.isMDXComponent=!0}}]);