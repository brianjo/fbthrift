"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3077],{3905:(e,t,a)=>{a.r(t),a.d(t,{MDXContext:()=>o,MDXProvider:()=>s,mdx:()=>g,useMDXComponents:()=>x,withMDXComponents:()=>p});var n=a(67294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},r.apply(this,arguments)}function d(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?d(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):d(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function m(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var o=n.createContext({}),p=function(e){return function(t){var a=x(t.components);return n.createElement(e,r({},t,{components:a}))}},x=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},s=function(e){var t=x(e.components);return n.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},N=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,d=e.parentName,o=m(e,["components","mdxType","originalType","parentName"]),p=x(a),s=l,N=p["".concat(d,".").concat(s)]||p[s]||u[s]||r;return a?n.createElement(N,i(i({ref:t},o),{},{components:a})):n.createElement(N,i({ref:t},o))}));function g(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,d=new Array(r);d[0]=N;var i={};for(var m in t)hasOwnProperty.call(t,m)&&(i[m]=t[m]);i.originalType=e,i.mdxType="string"==typeof e?e:l,d[1]=i;for(var o=2;o<r;o++)d[o]=a[o];return n.createElement.apply(null,d)}return n.createElement.apply(null,a)}N.displayName="MDXCreateElement"},73205:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>m,contentTitle:()=>d,default:()=>x,frontMatter:()=>r,metadata:()=>i,toc:()=>o});var n=a(83117),l=(a(67294),a(3905));const r={state:"draft"},d="Data Protocols",i={unversionedId:"spec/protocol/data",id:"spec/protocol/data",title:"Data Protocols",description:"How data is (de)serialized.",source:"@site/../doc/spec/protocol/data.md",sourceDirName:"spec/protocol",slug:"/spec/protocol/data",permalink:"/fbthrift/docs/spec/protocol/data",draft:!1,editUrl:"https://github.com/facebook/fbthrift/blob/main/thrift/website/../doc/spec/protocol/data.md",tags:[],version:"current",frontMatter:{state:"draft"},sidebar:"sidebar",previous:{title:"Channels",permalink:"/fbthrift/docs/spec/protocol/channel"},next:{title:"Interface Protocols",permalink:"/fbthrift/docs/spec/protocol/interface/"}},m={},o=[{value:"Thrift Types",id:"thrift-types",level:2},{value:"Serialization Formats",id:"serialization-formats",level:2},{value:"Binary Protocol",id:"binary-protocol",level:3},{value:"TYPE CODES",id:"type-codes",level:4},{value:"STRUCTS",id:"structs",level:4},{value:"BOOL",id:"bool",level:4},{value:"NUMERIC TYPES",id:"numeric-types",level:4},{value:"STRING",id:"string",level:4},{value:"LIST/SET",id:"listset",level:4},{value:"MAP",id:"map",level:4},{value:"Compact Protocol",id:"compact-protocol",level:3},{value:"TYPE CODES",id:"type-codes-1",level:4},{value:"STRUCTS",id:"structs-1",level:4},{value:"BOOL",id:"bool-1",level:4},{value:"INTEGRAL TYPES LARGER THAN 1 BYTE",id:"integral-types-larger-than-1-byte",level:4},{value:"OTHER NUMERIC TYPE",id:"other-numeric-type",level:4},{value:"STRING",id:"string-1",level:4},{value:"LIST/SET",id:"listset-1",level:4},{value:"MAP",id:"map-1",level:4},{value:"Varint Encoding",id:"varint-encoding",level:4},{value:"Handling Unknown Fields",id:"handling-unknown-fields",level:3},{value:"Other Protocols",id:"other-protocols",level:2},{value:"Frozen2",id:"frozen2",level:3},{value:"Debug Protocol",id:"debug-protocol",level:3},{value:"Deprecated",id:"deprecated",level:2}],p={toc:o};function x(e){let{components:t,...a}=e;return(0,l.mdx)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,l.mdx)("h1",{id:"data-protocols"},"Data Protocols"),(0,l.mdx)("p",null,"How ",(0,l.mdx)("a",{parentName:"p",href:"/fbthrift/docs/spec/definition/data"},"data")," is (de)serialized."),(0,l.mdx)("h2",{id:"thrift-types"},"Thrift Types"),(0,l.mdx)("p",null,"There are 13 different Thrift types that can appear in the serialized output."),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Type"),(0,l.mdx)("th",{parentName:"tr",align:null},"Description"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"STOP"),(0,l.mdx)("td",{parentName:"tr",align:null},"STOP does not represent data, it is used to indicate that no fields are left in a serialized struct.")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"BOOL"),(0,l.mdx)("td",{parentName:"tr",align:null},"Boolean")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"BYTE"),(0,l.mdx)("td",{parentName:"tr",align:null},"8-bit signed integer")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"DOUBLE"),(0,l.mdx)("td",{parentName:"tr",align:null},"Double precision floating point number")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"I16"),(0,l.mdx)("td",{parentName:"tr",align:null},"16-bit signed integer")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"I32"),(0,l.mdx)("td",{parentName:"tr",align:null},"32-bit signed integer or a Thrift enum")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"I64"),(0,l.mdx)("td",{parentName:"tr",align:null},"64-bit signed integer")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"STRING"),(0,l.mdx)("td",{parentName:"tr",align:null},"A String")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"STRUCT"),(0,l.mdx)("td",{parentName:"tr",align:null},"A Thrift struct or union")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"MAP"),(0,l.mdx)("td",{parentName:"tr",align:null},"Key-value mapping")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"LIST"),(0,l.mdx)("td",{parentName:"tr",align:null},"List of Thrift values")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"SET"),(0,l.mdx)("td",{parentName:"tr",align:null},"Set of Thrift values")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"FLOAT"),(0,l.mdx)("td",{parentName:"tr",align:null},"Single precision floating point number")))),(0,l.mdx)("h2",{id:"serialization-formats"},"Serialization Formats"),(0,l.mdx)("p",null,"Each serialization format encodes the above Thrift types in a different way."),(0,l.mdx)("h3",{id:"binary-protocol"},"Binary Protocol"),(0,l.mdx)("p",null,"The Binary protocol produces data in a non-human readable format."),(0,l.mdx)("h4",{id:"type-codes"},"TYPE CODES"),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Type"),(0,l.mdx)("th",{parentName:"tr",align:null},"Code"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"STOP"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x00"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"BOOL"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x02"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"BYTE"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x03"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"DOUBLE"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x04"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"I16"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x06"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"I32"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x08"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"I64"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x0A"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"STRING"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x0B"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"STRUCT"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x0C"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"MAP"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x0D"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"SET"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x0E"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"LIST"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x0F"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"FLOAT"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x13"))))),(0,l.mdx)("h4",{id:"structs"},"STRUCTS"),(0,l.mdx)("p",null,"A struct is serialized as a sequence of fields. Each field consists of an 8-bit type code (from the table above), a 16-bit field ID, and then the serialized value. The size of the serialized value depends on the value type. At the end, a STOP (",(0,l.mdx)("inlineCode",{parentName:"p"},"0x00"),") is written; there is no field id following the STOP code."),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Type Code"),(0,l.mdx)("th",{parentName:"tr",align:null},"Field ID"),(0,l.mdx)("th",{parentName:"tr",align:null},"Value"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"8 Bits"),(0,l.mdx)("td",{parentName:"tr",align:null},"16 Bits"),(0,l.mdx)("td",{parentName:"tr",align:null},"Variable")))),(0,l.mdx)("p",null,"Unions are serialized in the same way, but instead of having a sequence of fields, they contain exactly one field."),(0,l.mdx)("h4",{id:"bool"},"BOOL"),(0,l.mdx)("p",null,"Booleans are serialized as 8-bit values where ",(0,l.mdx)("inlineCode",{parentName:"p"},"0x00")," is False and ",(0,l.mdx)("inlineCode",{parentName:"p"},"0x01")," is True"),(0,l.mdx)("h4",{id:"numeric-types"},"NUMERIC TYPES"),(0,l.mdx)("p",null,"The Thrift numeric types are ",(0,l.mdx)("inlineCode",{parentName:"p"},"byte")," (",(0,l.mdx)("inlineCode",{parentName:"p"},"i8"),"), ",(0,l.mdx)("inlineCode",{parentName:"p"},"i16"),", ",(0,l.mdx)("inlineCode",{parentName:"p"},"i32"),", ",(0,l.mdx)("inlineCode",{parentName:"p"},"i64"),", ",(0,l.mdx)("inlineCode",{parentName:"p"},"float"),", and ",(0,l.mdx)("inlineCode",{parentName:"p"},"double"),". These are all serialized using their big-endian n-bit binary representations."),(0,l.mdx)("h4",{id:"string"},"STRING"),(0,l.mdx)("p",null,"Strings are encoded using a 32-bit length followed by a sequence of 8-bit characters"),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Length"),(0,l.mdx)("th",{parentName:"tr",align:null},"Payload"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"32-bit"),(0,l.mdx)("td",{parentName:"tr",align:null},"Length * 8-bit")))),(0,l.mdx)("h4",{id:"listset"},"LIST/SET"),(0,l.mdx)("p",null,"Lists and Sets are serialized in exactly the same way. First, the type code of the inner elements is written, then the signed 32-bit length, then the elements. Negative length values are invalid."),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Type Code"),(0,l.mdx)("th",{parentName:"tr",align:null},"Length"),(0,l.mdx)("th",{parentName:"tr",align:null},"Payload"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"8-bit"),(0,l.mdx)("td",{parentName:"tr",align:null},"32-bit"),(0,l.mdx)("td",{parentName:"tr",align:null},"Length * Variable")))),(0,l.mdx)("h4",{id:"map"},"MAP"),(0,l.mdx)("p",null,"Maps are serialized using the 8-bit type codes of the key and value types followed by the length and payload. The payload contains the key value pairs. Length is signed 32-bit; negative values are invalid."),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Key Type Code"),(0,l.mdx)("th",{parentName:"tr",align:null},"Value Type Code"),(0,l.mdx)("th",{parentName:"tr",align:null},"Length"),(0,l.mdx)("th",{parentName:"tr",align:null},"Key 1"),(0,l.mdx)("th",{parentName:"tr",align:null},"Value 1"),(0,l.mdx)("th",{parentName:"tr",align:null},"..."),(0,l.mdx)("th",{parentName:"tr",align:null},"Key n"),(0,l.mdx)("th",{parentName:"tr",align:null},"Value n"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"8-bit"),(0,l.mdx)("td",{parentName:"tr",align:null},"8-bit"),(0,l.mdx)("td",{parentName:"tr",align:null},"32-bit"),(0,l.mdx)("td",{parentName:"tr",align:null},"Variable"),(0,l.mdx)("td",{parentName:"tr",align:null},"Variable"),(0,l.mdx)("td",{parentName:"tr",align:null}),(0,l.mdx)("td",{parentName:"tr",align:null},"Variable"),(0,l.mdx)("td",{parentName:"tr",align:null},"Variable")))),(0,l.mdx)("h3",{id:"compact-protocol"},"Compact Protocol"),(0,l.mdx)("p",null,"The Compact protocol is similar to binary protocol, but some values are encoded so as to use fewer bytes. In particular, integral types are encoded using the ",(0,l.mdx)("a",{parentName:"p",href:"https://l.facebook.com/l.php?u=https%3A%2F%2Fdevelopers.google.com%2Fprotocol-buffers%2Fdocs%2Fencoding&h=AT0fFXtpm2VAb2FPLDl4g0p0TYi-JFoAW58CVsKuE5GJub43Dy-V2LP_rrxsXHzByrC2JCVIf0QVQnvFoeYj1K1RyMDbg8f1oX2-uI6uoGTcsxpBDlIUXesMcEOhCgLWfakjX1jQmtnFqwASFso"},"varint")," format."),(0,l.mdx)("h4",{id:"type-codes-1"},"TYPE CODES"),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Type"),(0,l.mdx)("th",{parentName:"tr",align:null},"Code"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"STOP"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x0"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"BOOL (True)"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x1"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"BOOL (False)"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x2"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"BYTE"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x3"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"I16"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x4"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"I32"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x5"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"I64"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x6"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"DOUBLE"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x7"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"STRING"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x8"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"LIST"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x9"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"SET"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0xA"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"MAP"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0xB"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"STRUCT"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0xC"))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"FLOAT"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0xD"))))),(0,l.mdx)("h4",{id:"structs-1"},"STRUCTS"),(0,l.mdx)("p",null,"A struct is serialized as a sequence of fields.\nEach field consists of a 4-bit field offset and a 4-bit type code. If the field offset is non-zero then it is added to the previous field ID that was written to obtain the current field ID (starting at 0). If it is 0, then the field ID is encoded as a variable length 16-bit integer. Boolean fields are encoded in the type code.\nType code (from the table above), a 16-bit field ID, and then the serialized value. The size of the serialized value depends on the value type. At the end, STOP (",(0,l.mdx)("inlineCode",{parentName:"p"},"0x00"),") is written; there is no additional field ID after the STOP code, even if the field offset is 0."),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Field Offset"),(0,l.mdx)("th",{parentName:"tr",align:null},"Type Code"),(0,l.mdx)("th",{parentName:"tr",align:null},"Value"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"4 Bits"),(0,l.mdx)("td",{parentName:"tr",align:null},"4 Bits"),(0,l.mdx)("td",{parentName:"tr",align:null},"Variable")))),(0,l.mdx)("p",null,"OR"),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Field Offset"),(0,l.mdx)("th",{parentName:"tr",align:null},"Type Code"),(0,l.mdx)("th",{parentName:"tr",align:null},"Field ID"),(0,l.mdx)("th",{parentName:"tr",align:null},"Value"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0x0")),(0,l.mdx)("td",{parentName:"tr",align:null},"4 Bits"),(0,l.mdx)("td",{parentName:"tr",align:null},"Variable"),(0,l.mdx)("td",{parentName:"tr",align:null},"Variable")))),(0,l.mdx)("p",null,"Unions are serialized in the same way, but instead of having a sequence of fields, they contain exactly one field."),(0,l.mdx)("h4",{id:"bool-1"},"BOOL"),(0,l.mdx)("p",null,"Booleans that are field values are encoded in the type code, so they have no additional serialization. If the boolean is part of collection (list, map, or set), then it is encoded as an 8-bit value where ",(0,l.mdx)("inlineCode",{parentName:"p"},"0x02")," is False and ",(0,l.mdx)("inlineCode",{parentName:"p"},"0x01")," is True."),(0,l.mdx)("h4",{id:"integral-types-larger-than-1-byte"},"INTEGRAL TYPES LARGER THAN 1 BYTE"),(0,l.mdx)("p",null,"The Integral types that are larger than 1 Byte (",(0,l.mdx)("inlineCode",{parentName:"p"},"i16"),", ",(0,l.mdx)("inlineCode",{parentName:"p"},"i32"),", and ",(0,l.mdx)("inlineCode",{parentName:"p"},"i64"),") are encoded using the Varint format."),(0,l.mdx)("h4",{id:"other-numeric-type"},"OTHER NUMERIC TYPE"),(0,l.mdx)("p",null,"The remaining Thrift numeric types (",(0,l.mdx)("inlineCode",{parentName:"p"},"byte"),", ",(0,l.mdx)("inlineCode",{parentName:"p"},"float"),", and ",(0,l.mdx)("inlineCode",{parentName:"p"},"double"),") are serialized in the same way as in binary protocol."),(0,l.mdx)("h4",{id:"string-1"},"STRING"),(0,l.mdx)("p",null,"Strings are encoded using a variable-sized length followed by a sequence of 8-bit characters"),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Length"),(0,l.mdx)("th",{parentName:"tr",align:null},"Payload"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"Variable"),(0,l.mdx)("td",{parentName:"tr",align:null},"Length * 8-bit")))),(0,l.mdx)("h4",{id:"listset-1"},"LIST/SET"),(0,l.mdx)("p",null,"Lists and Sets are serialized in exactly the same way. The first byte contains the length (if less than 16) and the type code of the inner elements. If the length is at least 16, then it is encoded as a variable length integer. The serialized elements come next.\nFirst, the type code of the inner elements is written, then the 32-bit length, then the elements."),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Length"),(0,l.mdx)("th",{parentName:"tr",align:null},"Type Code"),(0,l.mdx)("th",{parentName:"tr",align:null},"Payload"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"4-bit"),(0,l.mdx)("td",{parentName:"tr",align:null},"4-bit"),(0,l.mdx)("td",{parentName:"tr",align:null},"Length * Variable")))),(0,l.mdx)("p",null,"OR"),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Filler"),(0,l.mdx)("th",{parentName:"tr",align:null},"Type Code"),(0,l.mdx)("th",{parentName:"tr",align:null},"Length"),(0,l.mdx)("th",{parentName:"tr",align:null},"Payload"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"0xF")),(0,l.mdx)("td",{parentName:"tr",align:null},"4-bit"),(0,l.mdx)("td",{parentName:"tr",align:null},"Variable"),(0,l.mdx)("td",{parentName:"tr",align:null},"Length * Variable")))),(0,l.mdx)("h4",{id:"map-1"},"MAP"),(0,l.mdx)("p",null,"Maps contain a variable encoded length followed by the key and value types encoded in a single byte. Next comes the payload which is encoded in a similar way to the Binary protocol."),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Length"),(0,l.mdx)("th",{parentName:"tr",align:null},"Key Type"),(0,l.mdx)("th",{parentName:"tr",align:null},"Value Type"),(0,l.mdx)("th",{parentName:"tr",align:null},"Key 1"),(0,l.mdx)("th",{parentName:"tr",align:null},"Value 1"),(0,l.mdx)("th",{parentName:"tr",align:null},"..."),(0,l.mdx)("th",{parentName:"tr",align:null},"Key n"),(0,l.mdx)("th",{parentName:"tr",align:null},"Value n"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"Variable"),(0,l.mdx)("td",{parentName:"tr",align:null},"4-bit"),(0,l.mdx)("td",{parentName:"tr",align:null},"4-bit"),(0,l.mdx)("td",{parentName:"tr",align:null},"Variable"),(0,l.mdx)("td",{parentName:"tr",align:null},"Variable"),(0,l.mdx)("td",{parentName:"tr",align:null}),(0,l.mdx)("td",{parentName:"tr",align:null},"Variable"),(0,l.mdx)("td",{parentName:"tr",align:null},"Variable")))),(0,l.mdx)("h4",{id:"varint-encoding"},"Varint Encoding"),(0,l.mdx)("p",null,"Varint encoding is a variable length encoding for integer values.\nUnsigned integers are simplest. They are divided into 7-bit groups, from least to most significant, until there are no more non-zero groups. Each group is encoded as ",(0,l.mdx)("inlineCode",{parentName:"p"},"1xxxxxxx")," until the last group which is ",(0,l.mdx)("inlineCode",{parentName:"p"},"0xxxxxxx"),". So ",(0,l.mdx)("inlineCode",{parentName:"p"},"0x12")," - ",(0,l.mdx)("inlineCode",{parentName:"p"},"00010010")," in binary - would be literally encoded that way, since it's only a single group. ",(0,l.mdx)("inlineCode",{parentName:"p"},"0x37f0")," is ",(0,l.mdx)("inlineCode",{parentName:"p"},"00_1111101_1110000")," in binary (using ",(0,l.mdx)("inlineCode",{parentName:"p"},"_")," as a visual separator to show the 7 bit groups), so would be encoded as ",(0,l.mdx)("inlineCode",{parentName:"p"},"1_1110000")," ",(0,l.mdx)("inlineCode",{parentName:"p"},"0_1111101")," (again, ",(0,l.mdx)("inlineCode",{parentName:"p"},"_"),' as visual separator).\nSigned integers could be treated the same as unsigned, but it would result in all negative values being treated as large positive numbers, with correspondingly large encodings. It would be better to encode numbers with small absolute values more compactly, regardless of sign. Varint does this via "zigzag" encoding, where all numbers are mapped to a positive value before encoding:'),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Original"),(0,l.mdx)("th",{parentName:"tr",align:null},"Encoded as"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"0"),(0,l.mdx)("td",{parentName:"tr",align:null},"0")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"-1"),(0,l.mdx)("td",{parentName:"tr",align:null},"1")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"1"),(0,l.mdx)("td",{parentName:"tr",align:null},"2")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"-2"),(0,l.mdx)("td",{parentName:"tr",align:null},"3")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"2"),(0,l.mdx)("td",{parentName:"tr",align:null},"4")))),(0,l.mdx)("p",null,"Or more generally: ",(0,l.mdx)("inlineCode",{parentName:"p"},"(x << 1) ^ (x >>> (bits-1))")," where ",(0,l.mdx)("inlineCode",{parentName:"p"},"bits")," is the size of the value in bits, and ",(0,l.mdx)("inlineCode",{parentName:"p"},">>>")," is an arithmetic (sign-extending) shift.\nReversing this is ",(0,l.mdx)("inlineCode",{parentName:"p"},"(x >> 1) ^ -(x & 1)"),"."),(0,l.mdx)("h3",{id:"handling-unknown-fields"},"Handling Unknown Fields"),(0,l.mdx)("p",null,"If a decoder encounters an unknown field id while decoding a struct/union, it can continue by skipping that value and resuming with the rest of the stream. To allow this, fields and containers (map, set, list) contain the type code of the unknown type.\nFor non-compound types, skipping the value is trivial.\nFor compound types (struct/union and containers), skipping the value is a matter of skipping each field/entry; if a field/entry is also compound then the process is recursive."),(0,l.mdx)("h2",{id:"other-protocols"},"Other Protocols"),(0,l.mdx)("h3",{id:"frozen2"},"Frozen2"),(0,l.mdx)("p",null,"Frozen2 serializes data into a contiguous chunk of buffer, using its associated ",(0,l.mdx)("em",{parentName:"p"},"layout"),". ",(0,l.mdx)("em",{parentName:"p"},"Layout")," files are autogenerated from Thrift struct definition, and describes to the library what fields the struct contains."),(0,l.mdx)("p",null,"A contiguous buffer means several advantages:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"For offline use (serializing Thrift struct to disk, etc.), ",(0,l.mdx)("inlineCode",{parentName:"li"},"mmap"),"able data."),(0,l.mdx)("li",{parentName:"ul"},"To read values from buffer after serialization, location of the value is already known (think of a C struct), so values can be extracted in-place. Using specialized API is sometimes required.")),(0,l.mdx)("h3",{id:"debug-protocol"},"Debug Protocol"),(0,l.mdx)("p",null,"This protocol prints the Thrift object as a human readable, nicely indented string. It is write only now, you cannot deserialize from such a string. There is no guarantee that the format won't change -- it might be evolved in a non-backward compatible way. It should only be used for logging."),(0,l.mdx)("h2",{id:"deprecated"},"Deprecated"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"JSON. This protocol serializes Thrift objects into JSON objects (see ",(0,l.mdx)("a",{parentName:"li",href:"/fbthrift/docs/experimental/yaml"},"yaml"),")."),(0,l.mdx)("li",{parentName:"ul"},"SimpleJSON. This protocol is similar with JSON, it is simpler because it doesn't output verbose field type (see ",(0,l.mdx)("a",{parentName:"li",href:"/fbthrift/docs/experimental/yaml"},"yaml"),").")),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},'Phpserialize. This protocol serializes Thrift objects into PHP\'s "serialize" format. It is write only now, you cannot deserialize from PHP.')))}x.isMDXComponent=!0}}]);